<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="简单记录一些笔记"><title>Java常用类库与技巧 | Disda</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java常用类库与技巧</h1><a id="logo" href="/.">Disda</a><p class="description">Disda’s Dairy</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">Java常用类库与技巧</h1><div class="post-content"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>盘点了Java常用类库与技巧</p>
<a id="more"></a>

<!-- toc -->

<ul>
<li><a href="#java异常">Java异常</a><ul>
<li><a href="#异常处理机制主要回答了三个问题">异常处理机制主要回答了三个问题</a></li>
</ul>
</li>
<li><a href="#error和exception的区别">Error和Exception的区别</a><ul>
<li><a href="#从概念角度解析java的异常处理机制">从概念角度解析Java的异常处理机制</a></li>
<li><a href="#从责任角度看">从责任角度看</a></li>
</ul>
</li>
<li><a href="#常见error以及exception">常见Error以及Exception</a></li>
<li><a href="#java的异常处理机制">Java的异常处理机制</a></li>
<li><a href="#java异常的处理原则">Java异常的处理原则</a></li>
<li><a href="#高效主流的异常处理框架">高效主流的异常处理框架</a></li>
<li><a href="#try-catch的性能">Try-catch的性能</a><ul>
<li><a href="#java异常处理消耗性能的地方">Java异常处理消耗性能的地方【】</a></li>
</ul>
</li>
<li><a href="#java集合框架">Java集合框架</a><ul>
<li><a href="#数据结构考点">数据结构考点</a></li>
<li><a href="#算法考点">算法考点</a></li>
<li><a href="#考点拓展">考点拓展</a></li>
</ul>
</li>
<li><a href="#集合之map">集合之Map</a></li>
<li><a href="#为什么重写equals要重写hashcode">为什么重写equals要重写HashCode</a><ul>
<li><a href="#hashmap-hashtable-concurrenthashmap的区别">HashMap HashTable ConcurrentHashMap的区别</a></li>
<li><a href="#hashmapput方法的逻辑">HashMap：put方法的逻辑</a></li>
<li><a href="#hashmapget方法的逻辑">HashMap：get方法的逻辑</a></li>
<li><a href="#hashmap如何有效减少碰撞">HashMap：如何有效减少碰撞</a></li>
<li><a href="#为什么不直接用hashcode作为下标">为什么不直接用hashcode作为下标</a></li>
<li><a href="#hashmap扩容问题">HashMap：扩容问题</a></li>
<li><a href="#collectionssynchronizedmap和hashtable的区别">Collections.synchronizedMap和Hashtable的区别</a></li>
<li><a href="#concurrenthashmapput方法的逻辑">ConcurrentHashMap：put方法的逻辑</a></li>
<li><a href="#get-过程分析">get 过程分析</a></li>
<li><a href="#concurrenthashmap总结比起segment锁拆得更细">ConcurrentHashMap总结：比起Segment，锁拆得更细</a></li>
<li><a href="#concurrenthashmap别的需要注意的点">ConcurrentHashMap：别的需要注意的点</a></li>
<li><a href="#三者的区别">三者的区别</a></li>
</ul>
</li>
<li><a href="#java-util-concurrentjuc">Java util concurrent（JUC）</a><ul>
<li><a href="#javautilconcurrent提供了并发编程的解决方案">Java.util.concurrent:提供了并发编程的解决方案</a></li>
<li><a href="#juc包的分类">J.U.C包的分类</a></li>
<li><a href="#并发工具类">并发工具类</a><ul>
<li><a href="#countdownlatch让主线程等待一组事件发生后继续执行">CountDownLatch：让主线程等待一组事件发生后继续执行</a></li>
<li><a href="#cyclicbarrier阻塞当前线程等待其他线程">CyclicBarrier：阻塞当前线程，等待其他线程</a></li>
<li><a href="#semaphore控制某个资源可被同时访问的线程个数">Semaphore：控制某个资源可被同时访问的线程个数</a></li>
<li><a href="#exchanger两个线程到达同步点后相互交换数据">Exchanger：两个线程到达同步点后，相互交换数据</a></li>
</ul>
</li>
<li><a href="#blockingqueue提供可阻塞的入队和出队操作">BlockingQueue：提供可阻塞的入队和出队操作</a><ul>
<li><a href="#blockingqueue类型">BlockingQueue类型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#同步与异步">同步与异步</a></li>
<li><a href="#阻塞和非阻塞">阻塞和非阻塞</a></li>
<li><a href="#bio-同步阻塞io模式">BIO (同步阻塞I/O模式)</a></li>
<li><a href="#nio同步非阻塞">NIO（同步非阻塞）</a></li>
<li><a href="#aio-异步非阻塞io模型">AIO （异步非阻塞I/O模型）</a></li>
<li><a href="#nio-如何实现多路复用功能">NIO 如何实现多路复用功能</a></li>
<li><a href="#aio-bio-nio的适用场景">AIO、BIO、NIO的适用场景</a></li>
<li><a href="#nio的核心概念">NIO的核心概念</a><ul>
<li><a href="#nio应用和框架等等">NIO应用和框架等等</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h2><span id="java异常">Java异常</span></h2><h3><span id="异常处理机制主要回答了三个问题">异常处理机制主要回答了三个问题</span></h3><p>Ø What：异常类型回答了什么被抛出</p>
<p>Ø Where：异常堆栈跟踪回答了在哪抛出</p>
<p>Ø Why：异常信息回答了为什么被抛出</p>
<h2><span id="error和exception的区别">Error和Exception的区别</span></h2><p>  <img src="image-20200331101145233.png" alt>                             </p>
<h3><span id="从概念角度解析java的异常处理机制">从概念角度解析Java的异常处理机制</span></h3><p>Ø Error：程序无法处理的系统错误，编译器不做检查</p>
<p>Ø Exception：程序可以处理的异常，捕获后可能恢复</p>
<p>Ø 总结：前者是程序无法处理的错误，后者是可以处理的异常</p>
<ul>
<li><p>RuntimeException：不可预知的，程序应当自行避免</p>
</li>
<li><p>非RuntimeException：可预知的，从编译器校验的异常 </p>
</li>
</ul>
<h3><span id="从责任角度看">从责任角度看</span></h3><ol>
<li><p>Error属于JVM需要负担的责任；</p>
</li>
<li><p>RuntimeException是程序应该负担的责任；</p>
</li>
<li><p>Checked Exception可检查异常是Java编译器应该负担的责任</p>
<p><img src="image-20200331101305428.png" alt>             </p>
</li>
</ol>
<p>Checked Exception是编译器必须要追踪且处理的异常，可以使用Try catch处理，或者使用throws 来抛出异常。虽然抛出异常可以抛出异常的父类，但是还是不要泛化异常，以便查询到异常。 </p>
<p>如果写方法的时候不使用try catch来捕获异常，则需要在调用此方法的位置进行处理。</p>
<p><img src="image-20200331101329377.png" alt></p>
<p><img src="image-20200331101340011.png" alt></p>
<p>如果调用者知道如何处理异常便可以使用try catch来处理。</p>
<p>如果不知道的话也可以向上抛出异常，将异常层层上抛直到被处理，或者到顶层抛出异常为止，这里main函数是顶层，如果直接throws就会终止程序。</p>
<p><img src="image-20200331101509470.png" alt></p>
<h2><span id="常见error以及exception">常见Error以及Exception</span></h2><p><strong>RuntimeException</strong></p>
<ol>
<li><p>NullPointerException-空指针引用异常</p>
</li>
<li><p>ClassCastException-类型强制转换异常</p>
</li>
<li><p>IllegalArgumentException-传递非法参数异常</p>
</li>
<li><p>IndexOutOfBoundsException-下标越界异常</p>
</li>
<li><p>NumberFormatException-数字格式异常</p>
</li>
</ol>
<p><strong>非RuntimeException</strong></p>
<ol>
<li><p>ClassNotFoundException-找不到指定class的异常</p>
</li>
<li><p>IOException-IO操作异常</p>
</li>
</ol>
<p><strong>Error</strong></p>
<ol>
<li><p>NoClassDefFoundError-找不到class定义的异常</p>
</li>
<li><p>StackOverFlowError-深递归导致栈被耗尽而抛出的异常</p>
</li>
<li><p>OutOfMemoryError-内存溢出异常</p>
</li>
</ol>
<p><strong>NoClassDefFoundError的成因</strong></p>
<ol>
<li><p>类依赖的class或者jar不存在</p>
</li>
<li><p>类文件存在，但是存在不同的域中</p>
</li>
<li><p>大小写问题，javac编译的时候是无视大小写的，很有可能编译出来的class文件就与想要的不一样</p>
</li>
</ol>
<h2><span id="java的异常处理机制">Java的异常处理机制</span></h2><p>   Ø 抛出异常：创建异常对象，交由运行时系统处理</p>
<p>   Ø 捕获异常：寻找合适的异常处理器处理异常，否则终止运行</p>
<p>​    </p>
<p>   <strong>Try with resources</strong></p>
<p>   在括号里面声明继承<em>AutoClosable的对象，在结束时自动关闭。</em></p>
<p><img src="image-20200331181358769.png" alt></p>
<p>为了确保外部资源一定要被关闭，通常关闭代码被写入finally代码块中，当然我们还必须注意到关闭资源时可能抛出的异常，于是变有了下面的经典代码：   </p>
<p><img src="image-20200331181431748.png" alt>                            </p>
<p>直到JDK7中新增了try-with-resource语法，才实现了这一功能。</p>
<p>那什么是try-with-resource呢？简而言之，当一个外部资源的句柄对象（比如FileInputStream对象）实现了AutoCloseable接口，那么就可以将上面的板式代码简化为如下形式：</p>
<p> <img src="image-20200331181450895.png" alt></p>
<p><img src="image-20200331181458549.png" alt></p>
<p><img src="image-20200331181508292.png" alt></p>
<p>Finally是先于return执行的逻辑（因为无论是什么情况finally都会被执行的。） </p>
<p>将上述代码改造</p>
<p> <img src="image-20200331181520292.png" alt></p>
<p> <img src="image-20200331181527546.png" alt></p>
<p>Finally会在catch中return前执行，然后再执行catch中的代码。</p>
<p>抛出的异常<font color="orange">最多只会被catch一次</font>，被一个异常处理器处理，且catch块是<font color="red">按顺序</font>进行匹配的。</p>
<p>尽量不要捕获如Exception这样的<font color="red">通用异常</font>，而是应该捕获<font color="red">特定的异常</font>。一是为了代码更加清晰，二是为了不要捕获到我们不需要捕获的异常。</p>
<p><img src="image-20200331181652613.png" alt></p>
<p>这样也有问题。就是不要生吞异常：即将异常捕获却不做处理，难以定位并解决问题。</p>
<h2><span id="java异常的处理原则">Java异常的处理原则</span></h2><p>Ø 具体明确：抛出的异常应通过异常类名和message准确说明异常的类型和产生异常的原因；</p>
<p>Ø 提早抛出：应尽可能早的发现并抛出异常，便于精确定位问题；</p>
<p>Ø 延迟捕获：异常的捕获和处理应尽可能延迟，<font color="orange"><strong>让掌握更多信息的作用域来处理异常</strong></font></p>
<p>Ø 不生吞异常，不泛化异常。</p>
<h2><span id="高效主流的异常处理框架">高效主流的异常处理框架</span></h2><p><strong>在用户看来，应用系统发生的所有异常都是应用系统内部的异常</strong></p>
<p>Ø 设计一个通用的继承自RuntimeException的异常来统一处理</p>
<p>Ø 其余异常都统一转译为上述异常AppException</p>
<p>Ø 在catch之后，抛出上述异常的子类，并提供足以定位的信息</p>
<p>Ø 由前端接收AppException做统一处理</p>
<p><img src="image-20200331182250395.png" alt></p>
<h2><span id="try-catch的性能">Try-catch的性能</span></h2><h3><span id="java异常处理消耗性能的地方">Java异常处理消耗性能的地方【】</span></h3><p>Ø Try-catch块影响JVM的优化</p>
<p>Ø 异常对象实例需要保存栈快照等信息，开销较大 </p>
<p>Try catch开销较大，因此只在必要的代码段用try catch包住。 </p>
<h2><span id="java集合框架">Java集合框架</span></h2><h3><span id="数据结构考点">数据结构考点</span></h3><p>Ø 数组和链表的区别；</p>
<ul>
<li><p>数组静态分配内存，链表动态分配内存；</p>
</li>
<li><p>数组在内存中连续，链表不连续；</p>
</li>
<li><p>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；</p>
</li>
<li><p>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</p>
</li>
</ul>
<p>Ø 链表的操作，如反转，链表环路检测，双向链表，循环链表相关操作；</p>
<p>Ø 队列，栈的应用；</p>
<p>Ø 二叉树的遍历方式及其递归和非递归的实现</p>
<p>Ø 红黑树的旋转</p>
<h3><span id="算法考点">算法考点</span></h3><p>Ø 内部排序：如递归排序、交换排序（冒泡、快排）、选择排序、插入排序；</p>
<p>Ø 外部排序：应掌握如何利用有限的内存配合海量的外部存储来处理超大的数据集，写不出来也要有相关的思路</p>
<h3><span id="考点拓展">考点拓展</span></h3><p>Ø 哪些排序是不稳定的，稳定意味着什么</p>
<p>稳定的算法：归并、冒泡、插入</p>
<p>不稳定：快排、选择排序、堆排序</p>
<p>排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同</p>
<p>Ø 不同数据集，各种排序最好最差的情况</p>
<p>Ø 如何优化算法</p>
<p><img src="image-20200331182401175.png" alt></p>
<p><img src="image-20200331182420309.png" alt></p>
<p>Comparable接口：</p>
<p>必须实现 equals compareTo 和 Hashcode</p>
<p>CompareTo方法：<strong>自然排序</strong></p>
<p><img src="image-20200331182440072.png" alt></p>
<p><img src="image-20200331182449763.png" alt></p>
<p>这是在外部实现的comparator的<strong>客户化排序</strong></p>
<p><img src="image-20200331182506916.png" alt></p>
<p><img src="image-20200331182515418.png" alt></p>
<p>最后却打印出了一个元素，是因为compare方法重写了，认为名字相同就是同一个对象，而由于set不能保存同一个对象，因此只有一个结果。</p>
<p>因此</p>
<p><font color="red"><strong>如果客户化排序和自然排序共存，则以客户化排序为主。</strong></font></p>
<h2><span id="集合之map">集合之Map</span></h2><h2><span id="为什么重写equals要重写hashcode">为什么重写equals要重写HashCode</span></h2><p>因为不重写 equals 方法，执行 user1.equals(user2) 比较的就是两个对象的地址（即 user1 == user2），肯定是不相等的。</p>
<p><strong>hashCode</strong> <strong>是用于散列数据的快速存取，如利用</strong> <strong>HashSet/HashMap/Hashtable</strong> <strong>类来存储数据时，都会根据存储对象的</strong> <strong>hashCode</strong> <strong>值来进行判断是否相同的。</strong></p>
<p>下面以HashSet为例进行分析，我们都知道：在hashset中不允许出现重复对象，元素的位置也是不确定的。在hashset中又是怎样判定元素是否重复的呢？在java的集合中，判断两个对象是否相等的规则是：<br>     1.判断两个对象的hashCode是否相等</p>
<p>​       如果不相等，认为两个对象也不相等，完毕<br>​        如果相等，转入2<br>​      （这一点只是为了提高存储效率而要求的，其实理论上没有也可以，但如果没有，实际使用时效率会大大降低，所以我们这里将其做为必需的。）</p>
<p>​     2.判断两个对象用equals运算是否相等<br>​       如果不相等，认为两个对象也不相等<br>​       如果相等，认为两个对象相等（equals()是判断两个对象是否相等的关键）<br>​       为什么是两条准则，难道用第一条不行吗？不行，因为前面已经说了，hashcode()相等时，equals()方法也可能不等，所以必须用第2条准则进行限制，才能保证加入的为非重复元素。</p>
<p>Map中的Key是用set组成的，value是用collection组织起来的。</p>
<p> <img src="image-20200331182620663.png" alt></p>
<h3><span id="hashmap-hashtable-concurrenthashmap的区别">HashMap HashTable ConcurrentHashMap的区别</span></h3><p><img src="image-20200331182635063.png" alt></p>
<p>默认长度为16</p>
<p>实际上是通过位运算而不是取模</p>
<p><img src="image-20200331182648604.png" alt></p>
<p>Node是由hash值，键值对和next组成的。</p>
<p>数组分成一个个bucket</p>
<p>如果链表长度超过TREEIFY_THRESHOLD=8 就会变成红黑树</p>
<p>少于UNTREEIFY_THREHOLD=6就会变成链表</p>
<p>HashMap是使用LazyLoad的原则，在首次使用的时候才初始化。</p>
<p>Resize方法既具备初始化还具备扩容的作用</p>
<h3><span id="hashmapput方法的逻辑">HashMap：put方法的逻辑</span></h3><ol>
<li><p>如果HashMap未被初始化，则resize初始化</p>
</li>
<li><p>对Key求Hash值，然后再计算下标</p>
</li>
<li><p>如果没有碰撞，直接放入桶中</p>
</li>
<li><p>如果碰撞了，key相等就取出节点</p>
</li>
<li><p>如果是红黑树就以红黑树的方式插入节点，如果为链表以链表的方式链接到后面，</p>
</li>
<li><p>如果插入后链表长度超过阈值8，就把链表转成红黑树</p>
</li>
<li><p>如果节点已经存在就替换旧值</p>
</li>
<li><p>如果桶满了（容量16*加载因子0.75），就需要resize（扩容2倍后重排）</p>
</li>
</ol>
<p>桶就是数组</p>
<p>Resize后重新计算每个元素在数组中的位置（要么是当前位置要么是当前下标+oldCap）</p>
<p><img src="image-20200403163716667.png" alt></p>
<h3><span id="hashmapget方法的逻辑">HashMap：get方法的逻辑</span></h3><ul>
<li>计算 key 的 hash 值，根据 hash 值找到对应数组下标:     hash &amp; (length-1)</li>
<li>判断数组该位置处的元素是否刚好就是我们要找的</li>
<li>如果不是，判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据。</li>
<li>如果不是，遍历链表，直到找到相等(==或equals)的 key。</li>
</ul>
<p>扩容<img src="image-20200403163829060.png" alt></p>
<h3><span id="hashmap如何有效减少碰撞">HashMap：如何有效减少碰撞</span></h3><p>Ø 扰动函数：促使元素位置分布均匀，减少碰撞几率</p>
<p>Ø 使用final对象，并采用合适的equals()和hashCode()方法</p>
<h3><span id="为什么不直接用hashcode作为下标">为什么不直接用hashcode作为下标</span></h3><p><img src="image-20200403164018087.png" alt>         </p>
<p>直接用hashCode作为下标的话太浪费空间，有40亿的空间内存放不下这么大的数组且扩容前数组默认大小才16。混合原始hashCode的高位和低位，加大随机性同时能得到高低位的特征，在数组length较小的时候也能保证高低位参与hash运算当中，也不会有太大开销。最后用位与的操作来替代取模达到更高效率。（因为HashMap的长度是2的n次方，因此可以用取模来替代）</p>
<p> <img src="image-20200403164029114.png" alt></p>
<p>扩容因子是0.75，当hashmap填满百分之75的bucket的时候，将会创建原来hashMap 2倍大小的数组，并将原来的对象转移过去。这部叫做rehashing。</p>
<h3><span id="hashmap扩容问题">HashMap：扩容问题</span></h3><p>Ø 多线程环境下，调整大小会存在条件竞争，容易造成死锁</p>
<p>Ø Rehashing是一个比较耗时的过程</p>
<p> 由于HashMap不是线程安全的，因此为了使得其变成线程安全的可以使用</p>
<h3><span id="collectionssynchronizedmap和hashtable的区别">Collections.synchronizedMap和Hashtable的区别</span></h3><p>在synchronizedMap中有个Object类型的互斥成员，然后使用synchronized关键字修饰</p>
<p>SynchronizedMap的原理几乎和Hashtable的实现一致，hashtable将public的方法都添加了synchronized关键字。唯一区别就是<font color="orange">锁定的对象不一致。</font></p>
<p>Hashtable获取的是方法调用者this的锁，而synchronizedMap是使用定义好的成员变量mutex。</p>
<p>由于这两者在多线程情况下是<font color="orange">串行执行的，效率比较低</font>，因此我们需要ConcurrentHashMap</p>
<p><img src="image-20200403164302476.png" alt></p>
<p>现在做法：只锁定当前链表或者红黑树的首节点。</p>
<p><img src="image-20200403164412266.png" alt></p>
<p>ConcurrentHashMap不允许插入null key，而HashMap可以。</p>
<h3><span id="concurrenthashmapput方法的逻辑">ConcurrentHashMap：put方法的逻辑</span></h3><ol>
<li><p>判断Node[]数组是否初始化，没有则进行初始化操作</p>
</li>
<li><p>通过hash定位数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头节点），添加失败则进入下次循环。</p>
</li>
<li><p>如果hash为MOVED检查到内部正在扩容，就帮助它一块扩容。</p>
</li>
<li><p>如果f!=null，则使用synchronized锁住f元素（链表/红黑二叉树的头元素）</p>
<p>a)   如果是Node（链表结构）则执行链表的添加操作。</p>
<p>b)   如果是TreeNode（树型结构）则执行树添加操作。</p>
<p>c)   如果是reservationNode就抛出异常。</p>
</li>
<li><p>判断链表长度已经达到临界值8，当然这个8是默认值，也可以去调整，当节点数超过这个值就需要把链表转换为树结构。</p>
</li>
<li><p>判断数组是否需要扩容。</p>
</li>
</ol>
<h3><span id="get-过程分析">get 过程分析</span></h3><ul>
<li>计算 hash 值</li>
<li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li>
<li>根据该位置处结点性质进行相应查找</li>
</ul>
<p>·     如果该位置为 null，那么直接返回 null 就可以了</p>
<p>·     如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</p>
<p>·     如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，</p>
<p>·     如果以上 3 条都不满足，那就是链表，进行遍历比对即可</p>
<p>transient volatile int sizeCtl：散列表初始化和扩容的大小都是由该变量来控制。</p>
<p>·      当为负数时，它正在被初始化或者扩容。</p>
<p>·     -1表示正在初始化</p>
<p>·     -N表示N-1个线程正在扩容</p>
<h3><span id="concurrenthashmap总结比起segment锁拆得更细">ConcurrentHashMap总结：比起Segment，锁拆得更细</span></h3><p>Ø 首先使用无锁操作CAS插入头节点，失败则循环重试</p>
<p>Ø 若头节点已存在，则尝试获取头节点的同步锁，再进行操作</p>
<h3><span id="concurrenthashmap别的需要注意的点">ConcurrentHashMap：别的需要注意的点</span></h3><p>Ø size()方法和mappingCount()方法的异同，两者计算是否准确？</p>
<p>Ø 多线程环境下如何进行扩容</p>
<h3><span id="三者的区别">三者的区别</span></h3><p>Ø HashMap线程不安全，数组+链表+红黑树</p>
<p>Ø Hashtable线程安全，锁住整个对象，数组+链表</p>
<p>Ø ConcurrentHashMap线程安全，CAS+同步锁，数组+链表+红黑树</p>
<p>Ø HashMap的key、value均可为null，而其他的两个类不支持</p>
<h2><span id="java-util-concurrentjuc">Java util concurrent（JUC）</span></h2><h3><span id="javautilconcurrent提供了并发编程的解决方案">Java.util.concurrent:提供了并发编程的解决方案</span></h3><p>Ø CAS是java.util.concurrent.atomic包的基础</p>
<p>Ø AQS是java.util.concurrent.locks包以及一些常用类比如Samophore，ReentrantLock等类的基础</p>
<h3><span id="juc包的分类">J.U.C包的分类</span></h3><p>Ø 线程执行器executor</p>
<p>Ø 锁locks</p>
<p>Ø 原子变量类atomic</p>
<p>Ø 并发工具类tools</p>
<p>Ø 并发集合collections</p>
<p><img src="image-20200403164644589.png" alt></p>
<h3><span id="并发工具类">并发工具类</span></h3><p>Ø 闭锁CountDownLatch</p>
<p>Ø 栅栏CyclicBarrier</p>
<p>Ø 信号量Semaphore</p>
<p>Ø 交换器Exchanger</p>
<h4><span id="countdownlatch让主线程等待一组事件发生后继续执行">CountDownLatch：让主线程等待一组事件发生后继续执行</span></h4><p>Ø 事件指的是CountDownLatch里的countDown()方法</p>
<p>​     <img src="image-20200403164732266.png" alt></p>
<p>其他线程使用countDown后还会继续执行，并不代表该子线程已经执行完毕了，而是告诉主线程可以继续执行。每次调用countDown的时候cnt都会-1；</p>
<p> <img src="image-20200403164739889.png" alt></p>
<h4><span id="cyclicbarrier阻塞当前线程等待其他线程">CyclicBarrier：阻塞当前线程，等待其他线程</span></h4><p>Ø 等待其它线程，且会阻塞自己当前线程，所有线程必须同时到达栅栏位置后，才能继续执行；</p>
<p>Ø 所有线程到达栅栏处，可以触发执行另外一个预先设置的线程</p>
<p> <img src="image-20200403164751372.png" alt></p>
<p>每个线程调用await()的时候，cnt会减一，当cnt不为0的时候，会阻塞。当cnt=0，即所有线程都调用了await()，Ta主线程才会和t1 t2 t3一起执行。</p>
<p> <img src="image-20200403164805834.png" alt></p>
<h4><span id="semaphore控制某个资源可被同时访问的线程个数">Semaphore：控制某个资源可被同时访问的线程个数</span></h4><p><img src="image-20200403165110119.png" alt></p>
<p>· Semaphore 类是一个计数信号量，必须由获取它的线程释放， 通常用于限制可以访问某些资源（物理或逻辑的）线程数目。 </p>
<p>· 一个信号量有且仅有 3 种操作，且它们全部是原子的。 </p>
<ul>
<li>初始化、增加和减少。</li>
<li>增加可以为一个进程解除阻塞。</li>
<li>减少可以让一个进程进入阻塞。</li>
</ul>
<p>· Semaphore 管理一系列许可证。 </p>
<ul>
<li>每个     acquire() 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证。</li>
<li>每个     release() 方法增加一个许可证，这可能会释放一个阻塞的 acquire() 方法。</li>
<li>不使用实际的许可对象，Semaphore     只对可用许可的号码进行计数，并采取相应的行动。</li>
</ul>
<p>· Semaphore 在计数器不为 0 的时候对线程就放行，一旦达到 0，那么所有请求资源的新线程都会被阻塞，包括增加请求到许可的线程，Semaphore 是<font color="orange">不可重入的</font>。</p>
<ul>
<li>每一次请求一个许可都会导致计数器减少 1，同样每次释放一个许可都会导致计数器增加 1，一旦达到 0，新的许可请求线程将被挂起。</li>
</ul>
<p>· Semaphore 有两种模式，<strong>公平模式</strong> 和 <strong>非公平模式</strong>。 </p>
<ul>
<li><p>公平模式就是调用     acquire 的顺序就是获取许可证的顺序，遵循 FIFO。</p>
</li>
<li><p>非公平模式是抢占式的，也就是有可能一个新的获取线程恰好在一个许可证释放时得到了这个许可证，而前面还有等待的线程。</p>
<p><img src="image-20200403165155908.png" alt></p>
</li>
</ul>
<h4><span id="exchanger两个线程到达同步点后相互交换数据">Exchanger：两个线程到达同步点后，相互交换数据</span></h4><p> <img src="image-20200403165216566.png" alt></p>
<p> <img src="image-20200403165226727.png" alt></p>
<p><img src="image-20200403165237352.png" alt></p>
<h3><span id="blockingqueue提供可阻塞的入队和出队操作">BlockingQueue：提供可阻塞的入队和出队操作</span></h3><p> <img src="image-20200403165244330.png" alt></p>
<p><strong>主要用于生产者-消费者模式，在多线程场景时生产者线程在队列尾部添加元素，而消费者线程则在队列头部消费元素，通过这种方式能够达到将任务的生产和消费进行隔离的目的</strong></p>
<p>如果队列满了，入队操作将阻塞，如果队列空了，出队操作将阻塞。</p>
<p>Add()往队列尾部添加元素，成功返回true，失败抛出IllegalStateException</p>
<p>Put()往队列尾部添加元素，如果队列满了则阻塞当前线程直到能够添加成功为止</p>
<p>Offer()往队列尾部添加元素，成功返回true，失败返回false</p>
<p>Offer还能传参，指定timeout，如果超过timeout的话就会返回false，被中断就会抛出InterruptedException </p>
<p>Take是从队列头部取出元素，如果元素为空则一直等待有元素为止对应put</p>
<p>Poll对应offer，是从队列头部取出元素，如果队列为空最多等待timeout指定时间，中断抛出InterruptedException </p>
<p>remainingCapacity()获取当前队列剩余可存储元素数量 </p>
<p>remove 从队列移除指定对象 </p>
<p>contains判断队列中是否存在指定对象 </p>
<p>drainTo转移到指定集合。</p>
<h4><span id="blockingqueue类型">BlockingQueue类型</span></h4><p><strong>1.</strong>   <font color="orange"><strong>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列；</strong></font></p>
<p><strong>2.</strong>    <font color="orange"><strong>LinkedBlockingQueue：一个由链表结构组成的有界/无界阻塞队列；</strong></font></p>
<p><strong>3.</strong>   <font color="orange"> <strong>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</strong></font></p>
<p><strong>4.</strong>   <strong>DealyQueue：一个使用优先级队列实现的无界阻塞队列；</strong></p>
<p><strong>5.</strong>   <strong>SynchronousQueue：一个不存储元素的阻塞队列；</strong></p>
<p><strong>6.</strong>   <strong>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列；</strong></p>
<p><strong>7.</strong>   <strong>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列；</strong></p>
<p><strong>全都是线程安全的。</strong></p>
<p>1是FIFO</p>
<p>2无界指的是Integer.MAX_VALUE  FIFO</p>
<p>3.带优先级的队列不是FIFO</p>
<h2><span id="同步与异步">同步与异步</span></h2><ul>
<li><strong>同步：</strong> 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li>
<li><strong>异步：</strong> 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。</li>
</ul>
<h2><span id="阻塞和非阻塞">阻塞和非阻塞</span></h2><ul>
<li><strong>阻塞：</strong> 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li><strong>非阻塞：</strong> 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
<h2><span id="bio-同步阻塞io模式">BIO (同步阻塞I/O模式)</span></h2><p><img src="image-20200403170310675.png" alt></p>
<p>数据的读取写入必须阻塞在一个线程内等待其完成。</p>
<h2><span id="nio同步非阻塞">NIO（同步非阻塞）</span></h2><p><img src="image-20200403170244673.png" alt></p>
<p>构建多路复用的、同步非阻塞的IO操作</p>
<h2><span id="aio-异步非阻塞io模型">AIO （异步非阻塞I/O模型）</span></h2><p>基于事件和回调机制的异步非阻塞IO</p>
<p><img src="image-20200403170137243.png" alt></p>
<p>Ø 基于回调：实现CompletionHandler接口，调用时触发回调函数</p>
<p>Ø 返回Future：通过isDone()查看是否准备好，通过get()等待返回数据</p>
<p>仅仅Select阶段是阻塞的，可以避免大量客户端连接时频繁切换线程带来的问题。</p>
<h2><span id="nio-如何实现多路复用功能">NIO 如何实现多路复用功能</span></h2><p>Ø Selector选择器可以监听多个Channel通道</p>
<p>Ø 实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。</p>
<p>Ø Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p>
<h2><span id="aio-bio-nio的适用场景">AIO、BIO、NIO的适用场景</span></h2><p>·     BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。</p>
<p>·     NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</p>
<p>·     AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 </p>
<table>
<thead>
<tr>
<th><strong>属性\模型</strong></th>
<th><strong>阻塞BIO</strong></th>
<th><strong>非阻塞NIO</strong></th>
<th><strong>异步AIO</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Blocking</strong></td>
<td>阻塞并同步</td>
<td>非阻塞但同步</td>
<td>非阻塞并异步</td>
</tr>
<tr>
<td><strong>线程数（server：client）</strong></td>
<td>1:1</td>
<td>1:N</td>
<td>0:N</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>简单</td>
<td>较复杂</td>
<td>复杂</td>
</tr>
<tr>
<td><strong>吞吐量</strong></td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
<h2><span id="nio的核心概念">NIO的核心概念</span></h2><p><strong>1. 缓冲区Buffer</strong></p>
<p>Buffer是一个对象。它包含一些要写入或者读出的数据。</p>
<p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。</p>
<p>·     ByteBuffer：字节缓冲区</p>
<p>·     CharBuffer:字符缓冲区</p>
<p>·     ShortBuffer：短整型缓冲区</p>
<p>·     IntBuffer：整型缓冲区</p>
<p>·     LongBuffer:长整型缓冲区</p>
<p>·     FloatBuffer：浮点型缓冲区</p>
<p>·     DoubleBuffer：双精度浮点型缓冲区</p>
<p><strong>2.通道Channel</strong></p>
<p>Ø Channel是一个通道，可以通过它读取和写入数据，</p>
<p>Ø 通道和流不同之处在于通道是双向的</p>
<p>Ø Channel是全双工的</p>
<p>Channel有四种实现：</p>
<p>·     FileChannel:是从文件中读取数据。</p>
<p>·     DatagramChannel:从UDP网络中读取或者写入数据。</p>
<p>·     SocketChannel:从TCP网络中读取或者写入数据。</p>
<p>·     ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</p>
<p><strong>3.多路复用器Selector</strong></p>
<p><img src="image-20200403165738902.png" alt></p>
<p>Ø Selector选择器可以监听多个Channel通道</p>
<p>Ø 实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。</p>
<p>Ø Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p>
<p><img src="image-20200403165814493.png" alt></p>
<p><img src="image-20200403165805117.png" alt></p>
<p><img src="image-20200403170112067.png" alt></p>
<p><img src="image-20200403170119045.png" alt></p>
<h3><span id="nio应用和框架等等">NIO应用和框架等等</span></h3><p>例如：Dubbo(服务框架)，就默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<p>Netty是目前最流行的一个Java开源框架NIO框架，Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p>
<p>相比JDK原生NIO，Netty提供了相对十分简单易用的API，非常适合网络编程。</p>
</div></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'd154fff64901622afbb6',
  clientSecret: '5b3f1d58c331b54703e4477e1f8fa1e42e9c1082',
  repo: 'Disda-coding.github.io',
  owner: 'Disda-coding',
  admin: ['Disda-coding'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Disda.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> </a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Disda.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>