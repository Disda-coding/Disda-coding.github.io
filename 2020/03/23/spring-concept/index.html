<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="简单记录一些笔记"><title>spring-concept | Disda</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">spring-concept</h1><a id="logo" href="/.">Disda</a><p class="description">Disda’s Dairy</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">spring-concept</h1><div class="post-content"><p>Spinrg基础知识点 </p>
<a id="more"></a>

<!-- toc -->

<ul>
<li><a href="#iocinversion-of-control控制反转">IOC（Inversion of Control）：控制反转</a></li>
<li><a href="#依赖注入">依赖注入</a></li>
<li><a href="#依赖注入的方式">依赖注入的方式</a></li>
<li><a href="#依赖倒置原则ioc-di-ioc容器的关系">依赖倒置原则，IOC、DI、IOC容器的关系</a></li>
<li><a href="#ioc容器的优势">IOC容器的优势</a></li>
<li><a href="#spring-ioc支持的功能">Spring IOC支持的功能</a></li>
<li><a href="#spring-ioc容器的核心接口">Spring IOC容器的核心接口</a></li>
<li><a href="#beanfactoryspring框架最核心的接口">BeanFactory：Spring框架最核心的接口</a></li>
<li><a href="#beanfactory与applicationcontext的比较">BeanFactory与ApplicationContext的比较</a></li>
<li><a href="#三个常用的applicationcontext实现是">三个常用的ApplicationContext实现是:</a></li>
<li><a href="#getbean方法的代码逻辑">GetBean方法的代码逻辑</a></li>
<li><a href="#spring-bean的作用域">Spring Bean的作用域</a></li>
<li><a href="#关注点分离不同的问题交给不同的部分去解决">关注点分离：不同的问题交给不同的部分去解决</a></li>
<li><a href="#aop的三种织入方式">AOP的三种织入方式</a></li>
<li><a href="#aop的主要名词概念">AOP的主要名词概念</a></li>
<li><a href="#advice的种类">Advice的种类</a></li>
<li><a href="#aop的实现jdkproxy和cglib">AOP的实现：jdkProxy和Cglib</a></li>
<li><a href="#spring里代理模式的实现">Spring里代理模式的实现</a></li>
<li><a href="#事务传播">事务传播</a></li>
<li><a href="#什么是aop">什么是AOP</a></li>
</ul>
<!-- tocstop -->

<h2><span id="iocinversion-of-control控制反转">IOC（Inversion of Control）：控制反转</span></h2><p>有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用，更使得程序的整个体系结构变得非常灵活。</p>
<p>Ø Spring Core最核心的部分</p>
<p>Ø 需要了解依赖注入（Dependency Injection）</p>
<p><img src="image-20200406162508205.png" alt></p>
<p><img src="image-20200406162518521.png" alt></p>
<p>如果想把tire的size动态化改变就会牵一发而动全身，上层的代码也得修改</p>
<p><img src="image-20200406162547753.png" alt></p>
<h2><span id="依赖注入">依赖注入</span></h2><p>含义：把低层类作为参数传递给上层类，实现上层对下层的“控制”</p>
<p><img src="image-20200406162607619.png" alt></p>
<p>将tire作为构造函数的参数传入，并赋值给上层的成员变量。</p>
<p><img src="image-20200406162616526.png" alt></p>
<p>想要修改就可以只修改Tire的代码</p>
<p><img src="image-20200406162626533.png" alt></p>
<p><img src="image-20200406162635151.png" alt></p>
<p>DL是更主动的方法，会在需要的时候通过调用框架的方法来获取对象，获取时需要提供相关的文件路径，key等信息，来确定获取对象的状态。</p>
<p>DL已经被抛弃，因为它需要用户自己去使用API进行查找资源和组装对象，即有侵入性。</p>
<h2><span id="依赖注入的方式">依赖注入的方式</span></h2><p>Ø Setter</p>
<p>Ø Interface</p>
<p>Ø Constructor</p>
<p>Ø Annotation</p>
<h2><span id="依赖倒置原则ioc-di-ioc容器的关系">依赖倒置原则，IOC、DI、IOC容器的关系</span></h2><p><img src="image-20200406162723575.png" alt></p>
<h2><span id="ioc容器的优势">IOC容器的优势</span></h2><p>Ø 避免在各处使用new来创建类，并且可以做到统一维护</p>
<p>Ø 创建实例的时候不需要了解其中的细节 </p>
<p>在刚刚的例子中，我们是从低层往上层去new的，我们需要了解整个流程（从tire到luggage）的构造函数是怎么定义的才能一步步组装。 </p>
<p>而依赖注入则是从最上层开始查找依赖关系，然后再往上一步一步去new。有点像DFS</p>
<p><img src="image-20200406163228391.png" alt></p>
<p>蓝色部分是隐藏的细节</p>
<p><img src="image-20200406163238732.png" alt></p>
<p><img src="image-20200406163245378.png" alt></p>
<h2><span id="spring-ioc支持的功能">Spring IOC支持的功能</span></h2><p>Ø 依赖注入</p>
<p>Ø 依赖检查</p>
<p>Ø 自动装配</p>
<p>Ø 支持集合</p>
<p>Ø 指定初始化方法和销毁方法</p>
<p>Ø 支持回调方法</p>
<h2><span id="spring-ioc容器的核心接口">Spring IOC容器的核心接口</span></h2><p>Ø BeanFactory</p>
<p>Ø ApplicationContext</p>
<p><img src="image-20200406163330970.png" alt></p>
<p>Spring容器启动的时候会将注解或者XML里面Bean的定义解析成Spring内部的BeanDefinition</p>
<p><img src="image-20200406163354759.png" alt></p>
<p><img src="image-20200406163358035.png" alt></p>
<p>是个ConcurrentHashMap</p>
<h2><span id="beanfactoryspring框架最核心的接口">BeanFactory：Spring框架最核心的接口</span></h2><p>Ø 提供IOC的配置机制</p>
<p>Ø 包含Bean的各种定义，便于实例化Bean</p>
<p>Ø 建立Bean之间的依赖关系</p>
<p>Ø Bean生命周期的控制</p>
<p> <img src="image-20200406163455731.png" alt></p>
<p>ApplicationContext是BeanFactory的子接口之一</p>
<h2><span id="beanfactory与applicationcontext的比较">BeanFactory与ApplicationContext的比较</span></h2><p>Ø BeanFactory是Spring框架的基础设施，面向Spring</p>
<p>Ø ApplicationContext面向使用Spring框架的开发者</p>
<p>ApplicationContext的功能（实现多个接口）</p>
<p>Ø BeanFactory：能够管理、装配Bean</p>
<p>Ø ResourcePatternResolver：能够加载资源文件</p>
<p>Ø MessageSource：能够实现国际化等功能</p>
<p>Ø ApplicationEventPublisher：能够注册监听器，实现监听机制</p>
<p><img src="image-20200406163605604.png" alt></p>
<h2><span id="三个常用的applicationcontext实现是">三个常用的ApplicationContext实现是:</span></h2><ol>
<li>ClassPathXmlApplicationContext:它从classpath路径下的一个XML文件加载context的,将Context作为classpath下的资源。加载应用程序classpath下的context使用的代码如下：</li>
</ol>
<p>ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);</p>
<ol start="2">
<li>FileSystemXmlApplicationContext:它从文件系统的一个XML文件加载上下文定义的。从文件系统加载应用程序上下文通过如下代码实现。</li>
</ol>
<p>ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);</p>
<ol start="3">
<li>XmlWebApplicationContext:它从一个web应用程序中包含的XML文件加载context。</li>
</ol>
<h2><span id="getbean方法的代码逻辑">GetBean方法的代码逻辑</span></h2><p>Ø 转换beanName</p>
<p>Ø 从缓存中加载实例</p>
<p>Ø 实例化Bean</p>
<p>Ø 检测patternBeanFactory</p>
<p>Ø 初始化依赖的Bean</p>
<p>Ø 创建Bean</p>
<h2><span id="spring-bean的作用域">Spring Bean的作用域</span></h2><p>Ø Singleton：Spring的默认作用域，容器里拥有唯一的Bean实例</p>
<p>Ø Prototype：针对每个getBean请求，容器都会创建一个Bean实例</p>
<p>Ø Request：会对每个HTTP请求创建一个Bean实例</p>
<p>Ø Session：会对每个Session创建一个Bean实例</p>
<p>Ø globalSession：会为每个全局Http Session创建一个Bean实例，该作用域仅对Portlet有效</p>
<p><img src="image-20200406163629950.png" alt></p>
<p><img src="image-20200406163635201.png" alt></p>
<p><img src="https://www.javazhiyin.com/wp-content/uploads/2019/05/java0-1558500658.jpg" alt="深究Spring中Bean的生命周期"></p>
<h2><span id="关注点分离不同的问题交给不同的部分去解决">关注点分离：不同的问题交给不同的部分去解决</span></h2><p>Ø 面向切面编程AOP正是此种技术的体现</p>
<p>Ø 通用化功能代码的实现，对应的就是所谓的切面（Aspect）</p>
<p>Ø 业务功能代码和切面代码分开后，架构将变得高内聚低耦合</p>
<p>Ø 确保功能的完整性：切面最终需要被合并到业务中（Weave）</p>
<h2><span id="aop的三种织入方式">AOP的三种织入方式</span></h2><p>Ø 编译时织入：需要特殊的Java编译器，如AspectJ</p>
<p>Ø 类加载时织入：需要特殊的Java编译器，如AspectJ和AspectWerkz</p>
<p>Ø 运行时织入：Spring采用的方式，通过动态代理的方式，实现简单</p>
<h2><span id="aop的主要名词概念">AOP的主要名词概念</span></h2><p>Ø Aspect：通用功能的代码实现</p>
<p>Ø Target:被织入Aspect的对象</p>
<p>Ø Join Point：可以作为切入点的机会，所有方法都可以作为切入点</p>
<p>Ø Pointcut：Aspect实际被应用在的Join Point，支持正则</p>
<p>Ø Advice：类里的方法以及这个方法如何织入到目标方法的方式</p>
<p>Ø Weaving：AOP的实现过程</p>
<h2><span id="advice的种类">Advice的种类</span></h2><p>Ø 前置通知（Before）</p>
<p>Ø 后置通知（AfterReturning）</p>
<p>Ø 异常通知（AfterThrowing）</p>
<p>Ø 最终通知（After）</p>
<p>Ø 环绕通知（Around）</p>
<h2><span id="aop的实现jdkproxy和cglib">AOP的实现：jdkProxy和Cglib</span></h2><p>Ø 由AopProxyFactory根据AdvisedSupport对象的配置来决定</p>
<p>Ø 默认策略如果目标类是接口，则用JDKProxy来实现，否则用后者</p>
<p>Ø JDKProxy的核心：InvocationHandler接口和Proxy类</p>
<p>Ø Cglib：以继承的方式动态生成目标类的代理</p>
<p>Ø JDKProxy：通过Java的内部反射机制实现</p>
<p>Ø Cglib：借助ASM实现</p>
<p>Ø 反射机制在生成类的过程中比较高效</p>
<p>Ø ASM在生成类之后的执行过程中比较高效</p>
<p><strong><font color="orange">代理模式：接口+真实实现类+代理类</font></strong></p>
<p> <img src="image-20200406163709120.png" alt></p>
<p><img src="image-20200406163712301.png" alt></p>
<p><img src="image-20200406163716479.png" alt></p>
<p><img src="image-20200406163734578.png" alt></p>
<h2><span id="spring里代理模式的实现">Spring里代理模式的实现</span></h2><p>Ø 真实实现类的逻辑包含在getBean方法里</p>
<p>Ø getBean方法返回的实际上是Proxy的实例</p>
<p>Ø Proxy实例是Spring采用JDK Proxy或Cglib动态生成的</p>
<p><img src="image-20200406163746413.png" alt></p>
<h2><span id="事务传播">事务传播</span></h2><p>1.PROPAGATION_REQUIRED(默认实现)：当前没有事务则新建事务，有则加入当前事务</p>
<p>2.PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务则以非事务方式执行</p>
<p>3.PROPAGATION_MANDATORY：使用当前事务，如果没有则抛出异常</p>
<p>4.PROPAGATION__REQUIRES_NEW：新建事务，如果当前有事务则把当前事务挂起</p>
<p>5.PROPAGATION_NOT_SUPPORTED：以非事务的方式执行，如果当前有事务则把当前事务挂起</p>
<p>6.PROPAGATION_NEVER：以非事务的方式执行，如果当前有事务则抛出异常</p>
<p>7.PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行，如果当前没有事务，则执行1</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT</td>
<td>使用数据库本身使用的隔离级别 ORACLE（读已提交） MySQL（可重复读）</td>
</tr>
<tr>
<td>READ_UNCOMITTED</td>
<td>读未提交（脏读）最低的隔离级别，一切皆有可能。</td>
</tr>
<tr>
<td>READ_COMMITED</td>
<td>读已提交，ORACLE默认隔离级别，有幻读以及不可重复读风险。</td>
</tr>
<tr>
<td>REPEATABLE_READ</td>
<td>可重复读，解决不可重复读的隔离级别，但还是有幻读风险。</td>
</tr>
<tr>
<td>SERLALIZABLE</td>
<td>串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了</td>
</tr>
</tbody></table>
<h2><span id="什么是aop">什么是AOP</span></h2><p>在编译时，类加载时或运行时将通用代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</p>
</div></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'd154fff64901622afbb6',
  clientSecret: '5b3f1d58c331b54703e4477e1f8fa1e42e9c1082',
  repo: 'Disda-coding.github.io',
  owner: 'Disda-coding',
  admin: ['Disda-coding'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Disda.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> </a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Disda.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>