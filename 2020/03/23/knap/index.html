<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="简单记录一些笔记"><title>动态规划之背包问题 | Disda</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">动态规划之背包问题</h1><a id="logo" href="/.">Disda</a><p class="description">Disda’s Dairy</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">动态规划之背包问题</h1><div class="post-content"><p>尽可能详细的讲清楚背包问题，以及我所踩过的坑。</p>
<p>背包问题看本文就够了，一共6题。</p>
<a id="more"></a>

<!-- toc -->

<ul>
<li><a href="#入门样例">入门样例</a></li>
<li><a href="#01背包问题">01背包问题</a></li>
<li><a href="#完全背包问题">完全背包问题</a></li>
<li><a href="#凑数问题">凑数问题</a></li>
<li><a href="#leetcode-518-coin-change2">Leetcode 518 Coin Change2</a></li>
<li><a href="#多重背包问题">多重背包问题</a></li>
<li><a href="#494-target-sum">494. Target Sum</a></li>
<li><a href="#377-combination-sum-iv">377. Combination Sum IV</a></li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->

<p>首先我们先来看一道零钱凑整问题：</p>
<h2><span id="入门样例">入门样例</span></h2><p>•给定面值分别为1,4,16,64的硬币，每种硬币有无限个，给定一个N，求组成N最少需要的硬币的数量，若无法组成则返回-1.</p>
<p>注意，这题中的硬币都是2的n次方，（前一个数是后一个数的两倍或以上）因此可以使用贪心算法。</p>
<p>贪心算法和动态规划的关系就是可以用贪心算法做的题一定可以用动态规划做出来，但是能用动态规划做出来的题不一定能用贪心算法做出来。</p>
<p>这里上一张贪心和动态规划的图：</p>
<p><img src="image-20200324092356133.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coins</span><span class="params">(<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] val=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">16</span>,<span class="number">64</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=val.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(N&gt;=val[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> n = N/val[i];</span><br><span class="line">            cnt+=n;</span><br><span class="line">            N=N%val[i];</span><br><span class="line">            <span class="keyword">if</span> (N==<span class="number">0</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反例</strong>：假设给的硬币面值为1，9，10。要求去凑18元。</p>
<p>贪心的解应该是取1个10和8个1答案是9，但是正确答案其实是取2个9。</p>
<p><strong>先将零钱凑整问题放一放，来看下面一道题</strong></p>
<h2><span id="01背包问题">01背包问题</span></h2><p>给定n件物品，第i件物品的价值为v[i]，体积为w[i]，现在我们拥有一个容量为V的背包。</p>
<p>求能获得的最大价值，不一定装满。</p>
<br>

<p>在回答问题之前，先解释一下什么是01背包问题：<strong>即对于每件物品来说我们要么拿要么不拿，每件物品要么拿1件要么拿0件。</strong></p>
<p>了解完定义之后我们开始解这道题：</p>
<p>还是老方法解动态规划问题三部曲：</p>
<ol>
<li><p>下定义  </p>
<p>首先求什么我们定义什么。我们定义dp[i][j]为轮到第i件物品且背包还剩下j单位空间时所得到的最大价值。</p>
</li>
<li><p>写递推式</p>
<p>我们知道，在轮到第i件物品的时候我们可以选择拿或者不拿，那么此时的价值dp[i][j]就要么是拿了第i件物品，或者不拿第i件物品时的最大价值即：</p>
</li>
</ol>
<p>   $$<br>    dp[i][j]=Max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])<br>   $$<br>   <br></p>
<ol start="3">
<li><p>考虑初始条件</p>
<p>本题不需要考虑特殊初始条件</p>
</li>
</ol>
<p>技巧：有时候DP需要初始化第一行或者第一列，因为有时候数组下标可能越界，技巧就是多申请一行或者一列空间，并初始化为0，这样可以依靠这第0行来初始化第一行的值。例如第一行值依靠递推式取决于上一行的值。</p>
<p>以背包容量为10，物品大小和价值分别是A{3,4}，B{4,5}，C{5,6}。模拟走一遍流程：</p>
<p><img src="image-20200324095911869.png" alt></p>
<p>其实我们可以从递推式看出，当商品i为0的时候递推式变成了</p>
<p>dp[0][j]=Max(dp[-1][j],dp[-1][j-w[0]]+v[0])，因此我们新建了一行0来保证数组不越界，但是此时第i件物品还是从0开始到n-1，而dp的i已经变成1到n了。</p>
<p>因此递推式会有一点小小变化：</p>
<p>当j&gt;=w[i]时<br>$$<br>dp[i][j]=Max(dp[i-1][j],dp[i-1][j-w[i-1]]+v[i-1])<br>$$<br>else<br>$$<br>dp[i][j]=dp[i-1][j]<br>$$</p>
<p>即dp[1]对应物品w[0]和v[0]，一开始看会有点别扭，做多了就习惯了。</p>
<p>所以给出解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] v,<span class="keyword">int</span>[] w,<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[v.length+<span class="number">1</span>][V+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;v.length+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;V+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(w[i-<span class="number">1</span>]&lt;=j)</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]]+v[i-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[v.length][V];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> v[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">12</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">15</span>&#125;;</span><br><span class="line">        System.out.println(knapsack(v,w,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，dp[i][]只是依赖到了dp[i-1][]，所以依然可以去优化。</p>
<p>因为是二维的dp，我们就可以根据递推式得到dp[i][j]总是依赖于上一行的dp[i-1][j]以及dp[i-1][j-w[i]]，而之前说过滚动数组，因此我们可以使用一维dp来代替二维dp。</p>
<p>当j&gt;=w[i]时<br>$$<br>dp[j]=Math.max(dp[j],dp[j-w[i]]+v[i]);<br>$$<br>else<br>$$<br>dp[j]=dp[j]<br>$$<br>并且由于新建的数字默认填充0，因此我们都不需要新开一行数据，或者换句话说不需要初始化数组。</p>
<p>但是值得注意的是当我们计算dp[j]的时候要依赖于上一行的dp[j]（在这里没毛病，因为计算dp[j]的时候在dp数组中j这个位置保存的还是上一行的值）和dp[j-w[i]]（这就有问题了，假设w[i]为1，那么dp[j]依赖于上一行的dp[j-1]，这在二维的dp里面是没毛病的，但一维dp中我们在计算dp[j]的时候其实已经将dp[j-1]也更新过了，不再是上一行的值，而是当前行的值，因此就会出问题）。</p>
<p><img src="image-20200324102413012.png" alt></p>
<p>假设我们更新b5的值，b5=a5+b4。由于此时b5==a5，因此可以通过b5=b5+b4来做到，去掉a这一行。</p>
<p>相对于是将二维转一维。</p>
<p>但是如果b5=a3+x，由于a3已经被覆盖成b3因此我们拿不到。所以需要反向遍历, 保证之前的值没有被覆盖过</p>
<p><img src="abcd.jpg" alt></p>
<p>解决方案是什么呢？其实就是我们遍历数组的时候使用倒序的方法，即先遍历dp[j]再遍历dp[j-1]，因为dp[j-1]不依赖于数组下标大于j-1的位置的值，因此可以做到。</p>
<p>下面给出逐步优化的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knaps2</span><span class="params">(<span class="keyword">int</span>[] v, <span class="keyword">int</span>[] w, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-w[i-<span class="number">1</span>]]+v[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[j]=dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们注意到i是从1开始的，但是递推式里面并没有i的值，因此我们还可以写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knaps1</span><span class="params">(<span class="keyword">int</span>[] v, <span class="keyword">int</span>[] w, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i])&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[j]=dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knaps3</span><span class="params">(<span class="keyword">int</span>[] v, <span class="keyword">int</span>[] w, <span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[V + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length + <span class="number">1</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i-<span class="number">1</span>]; j--) </span><br><span class="line">            dp[j]=Math.max(dp[j],dp[j-w[i-<span class="number">1</span>]]+v[i-<span class="number">1</span>]);  </span><br><span class="line">        <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>我们还需要注意一下<font color="red">初始化</font>的问题：</p>
<p>​    至于初始化问题，不同的问法有不同初始化方法，如果不要求装满 的 话，价值为0就是背包的初始价值，如果要求装满，那么除了dp[0]之外所有的一开始都是不符合要求的，我们置为负无穷，这点下面会讲。</p>
<h2><span id="完全背包问题">完全背包问题</span></h2><p>看懂了01背包问题后，我们可以回到那道零钱凑整问题了。</p>
<p>假设penny总共有，1，2，5三种面额钱数，需要凑齐11块</p>
<p>但是这道题和01背包不一样的地方在于硬币是可以反复取的，因此是完全背包问题。</p>
<p><strong>下面再次解释一下为什么贪心算法不可取：</strong></p>
<p>​    看到可以选择任意多件，你也许会想，那还不容易，选性价比最高的就好了。</p>
<p>​    于是开启贪婪模式，把每种物品的价格除以体积来算出它们各自的性价比，然后只选择性价比最    高的物品放入背包中。</p>
<p>​    嗯，听起来好像没什么毛病，但仍旧有一个问题，那就是同一种物品虽然可以选择任意多件，但    仍旧只能以件为单位，也就是说单个物品是无法拆分的，不能选择半件，只能多选一件或者少选    一件。这样就造成了一个问题，往往无法用性价比最高的物品来装满整个背包，比如背包空间为    10，性价比最高的物品占用空间为7，那么剩下的空间该如何填充呢？</p>
<p>​    你当然会想到用性价比第二高的物品填充，如果仍旧无法填满，那就依次用第三、第四性价比物    品来填充。</p>
<p>​    听起来似乎可行，但我只需要举一个反例便能证明这个策略行不通。</p>
<p>​    想要举反例很简单，比如只有两个物品：物品A：价值5，体积5，物品B：价值8：体积7，背包    容量为10，物品B的性价比显然要比物品A高，那么用贪心算法必然会选择放入一个物品B，此    时，剩余的空间已无法装下A或者B，所以得到的最高价值为8，而实际上，选择放入两个物品A    即可得到更高的价值10。所以这里贪心算法并不适用。</p>
<p>开始解题：</p>
<ol>
<li><p>下定义</p>
<p>我们设dp[i][j]为凑到j元所需的硬币数量，回想一下背包问题，i是第i种硬币，j是容量。</p>
<p>因此在这里j就是容量（元）。</p>
</li>
<li><p>写递推式</p>
<p>if(j&gt;=coins[i])<br>$$<br>dp[i][j]=Min(dp[i-1][j],dp[i][j-coins[i]]+1)<br>$$<br>else<br>$$<br>dp[i][j]=dp[i-1][j]<br>$$<br>要么用之前的方法去凑硬币，要么在现在的基础上继续凑（可以多选）</p>
</li>
<li><p>初始化</p>
<p>全初始化成Integer.MAX_VALUE-1</p>
<p>二维解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange2</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[]= <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=amount ; i++) &#123;</span><br><span class="line">        dp[i]=<span class="number">0x7fff_fffe</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=coins.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=coins[i-<span class="number">1</span>];j&lt;=amount;j++)&#123;</span><br><span class="line">            dp[j]=Math.min(dp[j],dp[j-coins[i-<span class="number">1</span>]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]==<span class="number">0x7fff_fffe</span>?-<span class="number">1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   二维dp降维打击后：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) dp[i] = <span class="number">0x7fff_fffe</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++)<span class="comment">//part1</span></span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == <span class="number">0x7fff_fffe</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong>Q：为什么part1从coin开始呢？</strong><br>   A：因为我们知道当i&lt;coin的时候没办法凑因此直接跳过了,又由于是一维dp，dp[i][j]初始值是dp[i-1][j]而不是0，因此不需要else条件了。</p>
<p>   <strong>Q：为什么这次初始化成0x7ffffffe</strong><br>   A：原因分为三点，第一点是说如果和之前一样不初始化那么我们没办法判断到底能不能凑整，因此最终需要判断是否为0x7ffffffe。第二点是因为计算min的时候如果初始化为0永远都是0最小。第三点是说不初始化为最大值是因为dp[j]+1的时候可能会溢出。</p>
<p>   <strong>Q：为什么是正向遍历的？</strong><br>   A：从递推式可以看出来，dp[i][j]依赖的是dp[i][j-coin]和上一行值无关，因此需要得到该行最新值才能计算。</p>
<p><strong>01背包的递推式是：</strong></p>
<p>dp[i][j] = Math.<em>max</em>(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]);</p>
<p>所有的dp[i]都是从dp[i-1]推出来的，也就是说i只能在i-1的基础上被选中一次</p>
<p><strong>完全背包的递推式是：</strong></p>
<p>而我们硬币凑整问题dp[i]依赖于dp[i]因此可以一直取</p>
<p>dp[i][j]=Math.<em>min</em>(dp[i][j-coins[i-1]]+1,dp[i-1][j]);</p>
<h2><span id="凑数问题">凑数问题</span></h2><p>给定一个nums，和一个target，问能否使用nums中的数凑出target值（每个元素只能用一次）</p>
<p>示例：</p>
<p>输入：Nums= [1,2,5,5], target = 11</p>
<p>输出：true</p>
<p>上面分析了这么多了，每个元素只能用一次明显是01背包问题。再考虑一下初始化条件，dp[i][0]为true吧（无论用什么数字选0次都能凑出0）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">coins</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length+<span class="number">1</span>][target+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nums.length;i++) dp[i][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;nums.length+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;target+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]]||dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>降维打击：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">coins</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n:Nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = target; i &gt;= n; i--) &#123;</span><br><span class="line">            dp[i]|=dp[i-n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="leetcode-518-coin-change2">Leetcode 518 Coin Change2</span></h2><p>ou are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. </p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;2+2+1</span><br><span class="line">5&#x3D;2+1+1+1</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p>一分析就是完全背包问题了。注意初始化问题，dp[i][0]是1意思就是说无论用面值多少的硬币凑0元的话都有一种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[coins.length+<span class="number">1</span>][amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= coins.length; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + (j &gt;= coins[i-<span class="number">1</span>] ? dp[i][j-coins[i-<span class="number">1</span>]] : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[coins.length][amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>降维打击</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c:coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;=amount ; i++) &#123;</span><br><span class="line">            dp[i]+=dp[i-c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="多重背包问题">多重背包问题</span></h2><p>问题描述多加了一个每个物品有一个被取的上限，我们还是可以把该背包问题转化为我们的基础解法-01背包</p>
<p>如果他的重量*上限&gt;背包容量，是不是相当于完全背包？</p>
<p>不是的话我们分解即可对吧？</p>
<p>只需要用2进制表示出所有的可能，然后按照01背包的解法就可以了对吧。</p>
<p>看一道例题就懂了：</p>
<p>问给定容量为20的背包能装下的最大价值。</p>
<p><img src="image-20200324114647611.png" alt></p>
<p>straightforward：多重背包问题介于01背包和完全背包中，所以可以直接转换成01背包问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[] h, <span class="keyword">int</span>[] k, <span class="keyword">int</span>[] p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=-<span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;Integer&gt; weight=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; value=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k[i]; j++) &#123;</span><br><span class="line">            weight.add(++cnt,h[i]);</span><br><span class="line">            value.add(cnt,p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= weight.get(i-<span class="number">1</span>); j--) &#123;</span><br><span class="line">            dp[j]=Math.max(dp[j],dp[j-weight.get(i-<span class="number">1</span>)]+value.get(i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二进制优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiBag</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">E</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;<span class="comment">//重量</span></span><br><span class="line">        <span class="keyword">int</span> v;<span class="comment">//价值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">E</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.h=h;</span><br><span class="line">            <span class="keyword">this</span>.v=v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiBinary</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span>[] h,<span class="keyword">int</span>[] k,<span class="keyword">int</span>[] p)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;E&gt; lis = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index=-<span class="number">1</span>;<span class="comment">//代表拆分后的物品总数。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>  c=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(k[i]-c&gt;<span class="number">0</span>)&#123;<span class="comment">//c=1,2,4,8...节省空间</span></span><br><span class="line">                k[i]-=c;</span><br><span class="line">                E e=<span class="keyword">new</span> E(c*p[i],c*h[i]);</span><br><span class="line">                lis.add(++index,e);</span><br><span class="line">                c*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            E e=<span class="keyword">new</span> E(k[i]*p[i],k[i]*h[i]);</span><br><span class="line">            lis.add(++index,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;=lis.get(i).h ; j--) &#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-lis.get(i).h]+lis.get(i).v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2><span id="494-target-sum">494. Target Sum</span></h2><p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols <code>+</code> and <code>-</code>. For each integer, you should choose one from <code>+</code> and <code>-</code> as its new symbol.</p>
<p>Find out how many ways to assign symbols to make sum of integers equal to target S.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3. </span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 &#x3D; 3</span><br><span class="line">+1-1+1+1+1 &#x3D; 3</span><br><span class="line">+1+1-1+1+1 &#x3D; 3</span><br><span class="line">+1+1+1-1+1 &#x3D; 3</span><br><span class="line">+1+1+1+1-1 &#x3D; 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure>

<p>这种题其实换成正数集合和负数集合就行了。如上面的例子正数+负数=3 正数-负数=5，我们就可以求出需要凑的正数的值是多少，从而可以凑出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums) cnt+=i;</span><br><span class="line">    <span class="keyword">int</span> pos = (cnt+S)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> neg = (cnt-S)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;S||(cnt+S)%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[pos+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = pos; j &gt;=i ; j--) &#123;</span><br><span class="line">            dp[j]+=dp[j-i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[pos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="377-combination-sum-iv">377. Combination Sum IV</span></h2><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nums &#x3D; [1, 2, 3]</span><br><span class="line">target &#x3D; 4</span><br><span class="line"></span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">Note that different sequences are counted as different combinations.</span><br><span class="line"></span><br><span class="line">Therefore the output is 7.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= n) &#123;</span><br><span class="line">                dp[i] += dp[i - n];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为coins一个是可以循环一个不能。</p>
<p>其实看起来一样，但是一个是排列一个是组合。</p>
<p>主要还是定义不一样</p>
<p>一个是用定义dp[i][j]表示前i个硬币在剩余价值为j的时候的能凑成的方法数。（由于是按硬币为顺序的（硬币只走一次循环）因此3只能为1+2而不能为2+1）</p>
<p>一个是用定义dp[i][j]表示在剩余i价值用硬币j的时候的能凑成的方法数。（不管你3是1和2凑的还是2和1凑的=&gt;3等于1+2和2+1）</p>
<h2><span id="总结">总结</span></h2><p>如果不想看那么多就记住结论：</p>
<p>针对一维DP，如果元素只能出现一次，倒序来做，如果可以多次正序来做。</p>
</div></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'd154fff64901622afbb6',
  clientSecret: '5b3f1d58c331b54703e4477e1f8fa1e42e9c1082',
  repo: 'Disda-coding.github.io',
  owner: 'Disda-coding',
  admin: ['Disda-coding'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Disda.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> </a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Disda.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>