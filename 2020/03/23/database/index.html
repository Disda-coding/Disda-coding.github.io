<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="简单记录一些笔记"><title>数据库基础知识点 | Disda</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">数据库基础知识点</h1><a id="logo" href="/.">Disda</a><p class="description">Disda’s Blog</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">数据库基础知识点</h1><div class="post-content"><p>盘点了常考的数据库基础知识点</p>
<span id="more"></span>

<!-- toc -->

<ul>
<li><a href="#%E8%80%83%E7%82%B9">考点：</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93">如何设计一个关系型数据库 √</a><ul>
<li><a href="#rdbms%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">RDBMS：关系数据库管理系统</a></li>
<li><a href="#%E4%B8%A4%E5%A4%A7%E9%83%A8%E5%88%86">两大部分：</a></li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9D%97">索引模块</a><ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95">为什么要使用索引 √</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BF%A1%E6%81%AF%E8%83%BD%E6%88%90%E4%B8%BA%E7%B4%A2%E5%BC%95">什么样的信息能成为索引 √</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">索引的数据结构 √</a><ul>
<li><a href="#b-tree-">B-Tree -</a><ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
</ul>
</li>
<li><a href="#b%E6%A0%91%E6%98%AFb%E6%A0%91%E7%9A%84%E5%8F%98%E4%BD%93%E5%85%B6%E5%AE%9A%E4%B9%89%E4%B8%8Eb%E6%A0%91%E7%9B%B8%E5%90%8C%E9%99%A4%E4%BA%86">B+树是B树的变体，其定义与B树相同，除了</a></li>
<li><a href="#%E7%BB%93%E8%AE%BA">结论 √</a></li>
<li><a href="#%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB">拓展阅读</a></li>
<li><a href="#hash%E7%B4%A2%E5%BC%95">Hash索引</a><ul>
<li><a href="#%E7%BC%BA%E7%82%B9">缺点：</a></li>
</ul>
</li>
<li><a href="#bitmap">Bitmap √</a></li>
</ul>
</li>
<li><a href="#%E5%AF%86%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95">密集索引和稀疏索引 √</a></li>
<li><a href="#innodb">InnoDB</a><ul>
<li><a href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-">主键索引和非主键索引 -</a></li>
<li><a href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">聚簇索引和非聚簇索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%B9%B6%E4%BC%98%E5%8C%96%E6%85%A2%E6%9F%A5%E8%AF%A2sql">如何定位并优化慢查询Sql √</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E6%85%A2%E6%97%A5%E5%BF%97%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2sql">根据慢日志定位慢查询Sql</a><ul>
<li><a href="#%E6%98%BE%E7%A4%BA%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF">显示慢查询配置信息</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%95%B0%E9%87%8F">显示慢查询数量</a></li>
<li><a href="#%E6%89%93%E5%BC%80%E6%85%A2%E6%97%A5%E5%BF%97">打开慢日志</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%B6%E9%97%B4%E9%98%88%E5%80%BC">设置慢查询时间阈值</a></li>
</ul>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8explain%E5%88%86%E6%9E%90sql">利用Explain分析sql</a><ul>
<li><a href="#type%E4%BB%8E%E6%9C%80%E4%BC%98%E5%88%B0%E6%9C%80%E5%B7%AE">Type从最优到最差</a></li>
<li><a href="#extra">Extra</a></li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E6%94%B9sql%E5%B0%BD%E9%87%8F%E8%AE%A9sql%E8%B5%B0%E7%B4%A2%E5%BC%95">修改sql尽量让sql走索引</a><ul>
<li><a href="#%E8%B5%B0%E7%B4%A2%E5%BC%95">走索引</a></li>
<li><a href="#%E5%8A%A0%E7%B4%A2%E5%BC%95">加索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99">联合索引最左匹配原则 √</a><ul>
<li><a href="#%E6%88%90%E5%9B%A0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%98%AF%E7%BB%9D%E5%AF%B9%E6%9C%89%E5%BA%8F%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%AD%97%E6%AE%B5%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84">成因：第一个字段是绝对有序的，第二个字段是无序的。</a></li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E8%B6%8A%E5%A4%9A%E8%B6%8A%E5%A5%BD%E4%B9%88">索引是越多越好么 √</a></li>
<li><a href="#%E9%94%81%E6%A8%A1%E5%9D%97">锁模块</a><ul>
<li><a href="#%E4%BA%8C%E6%AE%B5%E9%94%81">二段锁</a></li>
<li><a href="#myisam%E4%B8%8Einnodb%E5%85%B3%E4%BA%8E%E9%94%81%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB">MyISAM与InnoDB关于锁方面的区别</a><ul>
<li><a href="#myisam%E9%80%82%E5%90%88%E7%9A%84%E5%9C%BA%E6%99%AF">MyISAM适合的场景 √</a></li>
<li><a href="#innodb%E9%80%82%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF">InnoDB适用的场景 √</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB-">数据库锁的分类：-</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7">数据库事务的四大特性</a></li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%90%84%E7%BA%A7%E5%88%AB%E4%B8%8B%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98">事务隔离级别以及各级别下并发访问问题</a><ul>
<li><a href="#1-%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1">1. 更新丢失</a></li>
<li><a href="#2-%E8%84%8F%E8%AF%BB%E8%AF%BB%E5%8F%96%E6%9C%AA%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE">2. 脏读（读取未提交数据）</a></li>
<li><a href="#3-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%80%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%8C%83%E5%9B%B4%E5%86%85%E4%B8%A4%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%8D%B4%E8%BF%94%E5%9B%9E%E4%BA%86%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE">3. 不可重复读（一个事务范围内两个相同的查询却返回了不同数据）</a><ul>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">解决方法：</a></li>
</ul>
</li>
<li><a href="#4-%E5%B9%BB%E8%AF%BB%E5%89%8D%E5%90%8E%E5%A4%9A%E6%AC%A1%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%80%BB%E9%87%8F%E4%B8%8D%E4%B8%80%E8%87%B4">4. 幻读：（前后多次读取，数据总量不一致）</a></li>
</ul>
</li>
<li><a href="#innodb%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB">InnoDB可重复读隔离级别下如何避免幻读</a><ul>
<li><a href="#%E5%BD%93%E5%89%8D%E8%AF%BB">当前读</a></li>
<li><a href="#%E5%BF%AB%E7%85%A7%E8%AF%BB">快照读</a><ul>
<li><a href="#rc%E7%BA%A7%E5%88%AB%E4%B8%8B">RC级别下</a></li>
<li><a href="#%E5%9C%A8rr%E7%BA%A7%E5%88%AB%E4%B8%8B">在RR级别下</a></li>
</ul>
</li>
<li><a href="#gap%E9%94%81">Gap锁</a><ul>
<li><a href="#1-%E4%B8%BB%E9%94%AE%E6%88%96%E8%80%85%E5%94%AF%E4%B8%80%E9%94%AE">1. 主键或者唯一键</a><ul>
<li><a href="#%E5%85%A8%E9%83%A8%E5%91%BD%E4%B8%AD">全部命中</a></li>
<li><a href="#%E5%85%A8%E4%B8%8D%E5%91%BD%E4%B8%AD">全不命中</a></li>
<li><a href="#%E9%83%A8%E5%88%86%E5%91%BD%E4%B8%AD">部分命中</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E5%85%A8%E5%91%BD%E4%B8%AD">如果全命中</a></li>
</ul>
</li>
<li><a href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%93%E5%89%8D%E8%AF%BB%E4%B8%8B">非唯一索引和不走索引的当前读下</a><ul>
<li><a href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95">非唯一索引</a></li>
<li><a href="#%E4%B8%8D%E8%B5%B0%E7%B4%A2%E5%BC%95">不走索引</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#rc-rr%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84innodb%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%AF%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0">RC、RR级别下的InnoDB的非阻塞读如何实现</a></li>
</ul>
</li>
<li><a href="#%E5%85%B3%E9%94%AE%E8%AF%AD%E6%B3%95">关键语法</a><ul>
<li><a href="#group-by">GROUP BY</a></li>
<li><a href="#having">HAVING</a></li>
<li><a href="#countsummaxminavg">COUNT,SUM,MAX,MIN,AVG</a></li>
</ul>
</li>
<li><a href="#%E7%90%86%E8%AE%BA%E8%8C%83%E5%BC%8F">理论范式</a><ul>
<li><a href="#1nf">1NF</a></li>
<li><a href="#2nf">2NF</a></li>
<li><a href="#3nf">3NF</a></li>
<li><a href="#%E5%85%B6%E5%AE%83%E8%8C%83%E5%BC%8F">其它范式</a></li>
<li><a href="#%E4%BC%98%E7%BC%BA%E7%82%B9">优缺点</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5">数据库连接</a></li>
</ul>
<!-- tocstop -->

<h2><span id="考点">考点：</span></h2><p>架构，索引，锁，语法，理论范式</p>
<h2><span id="如何设计一个关系型数据库">如何设计一个关系型数据库 √</span></h2><h3><span id="rdbms关系数据库管理系统">RDBMS：关系数据库管理系统</span></h3><p><img src="/2020/03/23/database/clip_image002.jpg"></p>
<h3><span id="两大部分">两大部分：</span></h3><p>​	<strong>存储部分</strong>和<strong>程序部分</strong></p>
<h2><span id="索引模块">索引模块</span></h2><h3><span id="为什么要使用索引">为什么要使用索引 √</span></h3><p>​	避免全表扫描去查找数据，提升检索效率</p>
<h3><span id="什么样的信息能成为索引">什么样的信息能成为索引 √</span></h3><p>​	主键，唯一键等能让数据<font color="red">具备一定区分性的字段</font></p>
<h3><span id="索引的数据结构">索引的数据结构 √</span></h3><p>​	二叉查找树，B-Tree，B+Tree（MySql），Hash结构</p>
<h4><span id="b-tree-">B-Tree -</span></h4><p>即遍观整棵树，子节点最多的个数是m，那么这棵树就是m阶树。</p>
<p><img src="/2020/03/23/database/clip_image002-1584950180040.jpg"></p>
<h5><span id="定义">定义</span></h5><ul>
<li><p>根节点至少包括两个孩子</p>
</li>
<li><p>树中每个节点最多含有m个孩子（m&gt;&#x3D;2）</p>
</li>
<li><p>除根节点和叶节点外，其他每个节点至少有ceil(m&#x2F;2)个孩子</p>
</li>
<li><p>所有叶子节点都位于同一层</p>
</li>
</ul>
<p>假设每个非终端结点中包含n个关键字信息，其中</p>
<p>A） Ki（i&#x3D;1…n）为关键字，且关键字按顺序升序排序K(i-1)&lt;Ki</p>
<p>B） 关键字的个数n必须满足：[ceil(m&#x2F;2)-1]&lt;&#x3D;n&lt;&#x3D;m-1</p>
<p>C） 非叶子结点的指针：P[1]，P[2]，…，P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于（K[i-1],K[i]）的子树 </p>
<h4><span id="b树是b树的变体其定义与b树相同除了">B+树是B树的变体，其定义与B树相同，除了</span></h4><ul>
<li><p>非叶子节点的子树指针与关键字个数相同</p>
</li>
<li><p>非叶子节点的子树指针P[i]，指向关键字值[K[i],K[i+1])的子树</p>
</li>
<li><p>非叶子节点仅用来索引，数据都保存在叶子节点中</p>
</li>
<li><p>所有叶子节点均有一个链指针指向下一个叶子节点</p>
</li>
</ul>
<h4><span id="结论">结论 √</span></h4><ul>
<li><p>B+Tree更适合用来做存储索引</p>
</li>
<li><p>B+树的查询效率更加稳定</p>
</li>
<li><p>B+树更有利于对数据库的扫描</p>
</li>
</ul>
<h4><span id="拓展阅读">拓展阅读</span></h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7a2017e830a0">https://www.jianshu.√com/p/7a2017e830a0</a></p>
<h4><span id="hash索引">Hash索引</span></h4><h5><span id="缺点">缺点：</span></h5><ul>
<li><p>仅仅能满足“&#x3D;”，“IN”，不能使用范围查询</p>
</li>
<li><p>无法被用来避免数据的排序操作</p>
</li>
<li><p>不能利用部分索引键查询</p>
</li>
<li><p>不能避免表扫描</p>
</li>
<li><p>遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高</p>
</li>
</ul>
<h4><span id="bitmap">Bitmap √</span></h4><p><img src="/2020/03/23/database/clip_image002-1584950246040.jpg"></p>
<p><strong>位图索引</strong>是一种使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BD%8D%E5%9B%BE">位图</a>的特殊数据库索引。</p>
<p>主要针对大量相同值的列而创建(例如：类别，操作员，部门ID,库房ID等),</p>
<p>索引块的一个索引行中存储键值和起止Rowid,以及这些键值的位置编码,</p>
<p>位置编码中的<font color="red">每一位表示键值对应的数据行的有无</font>.一个块可能指向的是几十甚至成百上千行数据的位置.</p>
<p><strong>适合</strong>：</p>
<ol>
<li><p>这种方式存储数据,相对于B+Tree索引,<font color="red">占用的空间非常小,创建和使用非常快</font>.</p>
</li>
<li><p>当根据键值查询时,<font color="red">可以根据起始Rowid和位图状态,快速定位数据</font>.</p>
</li>
<li><p>当根据键值做and,or或 in(x,y,..)查询时,<font color="red">直接用索引的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BD%8D%E5%9B%BE/1017781">位图</a>进行<strong>或运算</strong>,快速得出结果行数据.</font></p>
</li>
</ol>
<p><strong>不适合</strong>：</p>
<ol>
<li><p>不适合键值较多的列（重复值较少的列）；</p>
</li>
<li><p>不适合update、insert、delete频繁的列，代价很高。</p>
</li>
</ol>
<h3><span id="密集索引和稀疏索引">密集索引和稀疏索引 √</span></h3><p>Ø 密集索引文件中的每个搜索码值都对应一个索引值</p>
<p>Ø 稀疏索引文件只为索引码的某些值建立索引项</p>
<p><img src="/2020/03/23/database/clip_image004.jpg"></p>
<p><strong>密集索引</strong>：叶子节点保存的不只是键值，还保存了位于<font color="red"><strong>同一行记录里的其他列的信息</strong></font>，由于密集索引决定了表的物理排列顺序，一个表只有一个物理排列顺序，所以一个表只能创建一个密集索引</p>
<p><strong>稀疏索引</strong>：叶子节点仅保存了<font color="red">键位信息以及该行数据的地址</font>，有的稀疏索引只保存了键位信息及其主键 </p>
<h3><span id="innodb">InnoDB</span></h3><p>Ø 若一个主键被定义，该主键则作为密集索引</p>
<p>Ø 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引</p>
<p>Ø 若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）</p>
<p>Ø 非主键索引存储<font color="blue">相关键位</font>和<font color="blue">其对应的主键值</font>，包含两次查找</p>
<h4><span id="主键索引和非主键索引-">主键索引和非主键索引 -</span></h4><p>主键索引和非主键索引的区别是：非主键索引的叶子节点存放的是<font color="red"><strong>主键的值</strong></font>，而主键索引的叶子节点存放的是<font color="red"><strong>整行数据</strong></font>，其中非主键索引也被称为二级索引，而主键索引也被称为聚簇索引。</p>
<p><img src="/2020/03/23/database/image-20200323160333643.png"></p>
<p> <font color="red">InnoDB使用的是密集索引</font></p>
<ul>
<li>主键索引的B+Tree的叶子节点包含索引和数据</li>
</ul>
<p> 红色的是稀疏索引的条件筛选，需要两个步骤</p>
<ul>
<li><pre><code>第一步：在稀疏索引的B+Tree中索引该键
</code></pre>
</li>
<li><p>第二步：使用主键在主键索引B+Tree中再执行一次检索操作</p>
</li>
</ul>
<p><font color="red">MyISAM使用的均为稀疏索引</font></p>
<p>节点结构完全一致，只是存储内容不一样。<font color="red">主键索引B+Tree存储主键，辅助键B+Tree存储了辅助键。</font>索引和数据是分开存储的。通过辅助键检索无需访问主键的索引树。</p>
<h4><span id="聚簇索引和非聚簇索引">聚簇索引和非聚簇索引</span></h4><ul>
<li><p>聚簇索引：将<font color="orange"><strong>存储数据</strong></font>与<font color="blue"><strong>索引</strong></font>放到了一块，找到索引也就找到了数据</p>
</li>
<li><p>非聚簇索引：将数据存储与索引分开，索引结构的叶子节点指向了数据的对应行。</p>
</li>
</ul>
<h2><span id="如何定位并优化慢查询sql">如何定位并优化慢查询Sql √</span></h2><p>Ø 根据慢日志定位慢查询sql</p>
<p>Ø 使用explain等工具分析sql</p>
<p>Ø 修改sql或者尽量让sql走索引</p>
<h2><span id="根据慢日志定位慢查询sql">根据慢日志定位慢查询Sql</span></h2><h4><span id="显示慢查询配置信息">显示慢查询配置信息</span></h4><p><img src="/2020/03/23/database/clip_image002-1584950743345.jpg"></p>
<h4><span id="显示慢查询数量">显示慢查询数量</span></h4><p><img src="/2020/03/23/database/clip_image003.png"></p>
<p>本次回合的慢条数，重启客户端清零</p>
<h4><span id="打开慢日志">打开慢日志</span></h4><p><img src="/2020/03/23/database/clip_image004.png"></p>
<p>重启无效</p>
<h4><span id="设置慢查询时间阈值">设置慢查询时间阈值</span></h4><p><img src="/2020/03/23/database/clip_image005.png"></p>
<p>需要重新连接数据库</p>
<p>可以对my.ini或者my.cnf去配置，永久保存</p>
<h3><span id="利用explain分析sql">利用Explain分析sql</span></h3><p><img src="/2020/03/23/database/clip_image007.jpg"></p>
<h4><span id="type从最优到最差">Type从最优到最差</span></h4><p><img src="/2020/03/23/database/clip_image009.jpg"></p>
<p>红色的为全表扫描</p>
<h4><span id="extra">Extra</span></h4><p>Extra中出现以下2项意味着MySQL根本不能使用索引，效率会受到重大影响，应尽可能对此进行优化</p>
<table>
<thead>
<tr>
<th><strong>Etra 项</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Using filesort</strong></td>
<td>表示MySQL会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容，可能在内存或者磁盘上进行排序，MySQL中无法利用索引完成的排序操作称为“文件排序”</td>
</tr>
<tr>
<td><strong>Using temporary</strong></td>
<td>表示MySQL在对查询结果排序时使用临时表，常见于排序order by和分组查询group by</td>
</tr>
</tbody></table>
<h3><span id="修改sql尽量让sql走索引">修改sql尽量让sql走索引</span></h3><h4><span id="走索引">走索引</span></h4><p><img src="/2020/03/23/database/clip_image002-1584950929126.jpg"></p>
<p><img src="/2020/03/23/database/clip_image004-1584950929126.jpg"></p>
<p>Name没有走索引，而account有索引，因此我们可以将语句优化。</p>
<p><img src="/2020/03/23/database/clip_image006.jpg"></p>
<h4><span id="加索引">加索引</span></h4><p><img src="/2020/03/23/database/clip_image008.jpg"></p>
<h2><span id="联合索引最左匹配原则">联合索引最左匹配原则 √</span></h2><p><img src="/2020/03/23/database/clip_image010.jpg"></p>
<p><img src="/2020/03/23/database/clip_image012.jpg"></p>
<p>删除title后依然走联合索引</p>
<p><img src="/2020/03/23/database/clip_image014.jpg"></p>
<p>把area删除只留下title后就不走联合索引了</p>
<p>在联合索引中area在最左边</p>
<p>1． 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如a&#x3D;3 and b&#x3D;4 and c&gt;5 and d&#x3D;6，如果建立（a,b,c,d）顺序的索引，d是用不到索引的（<font color="red">c可以用到索引</font>），如果建立（a,b,d,c）的索引则都可以用到，a,b,d的顺序可以任意调整</p>
<p>2． &#x3D;和in可以乱序，比如a&#x3D;1 and b&#x3D;2 and c&#x3D;3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
<h4><span id="成因第一个字段是绝对有序的第二个字段是无序的">成因：第一个字段是绝对有序的，第二个字段是无序的。</span></h4><p>直接用第二个字段是没办法走索引的，因为它是无序的。</p>
<p><img src="/2020/03/23/database/clip_image016.jpg"></p>
<p>用column3建立b+tree，通过关键词查找alice然后排序。单靠column2无法走b+tree索引。</p>
<h2><span id="索引是越多越好么">索引是越多越好么 √</span></h2><p>Ø 数据量小的表不需要建立索引，建立会增加额外的索引开销</p>
<p>Ø 数据变更需要维护索引，因此更多的索引意味着更多的维护成本</p>
<p>Ø 更多的索引意味着也需要更多的空间</p>
<h2><span id="锁模块">锁模块</span></h2><h3><span id="二段锁">二段锁</span></h3><p><strong>两阶段的含义是指在同一个事务内，对涉及的所有数据项进行先加锁，然后才对所有的数据项解锁</strong>。</p>
<p><em><strong>但第一阶段加共享锁后影响了其他事务的写操作、加排它锁后影响了其他事务的读操作</strong></em>，所以较大地影响了其他事务的运行。只有第二阶段释放了所有的数据项上的锁之后，才能运行其他要操作相同数据项的事务。</p>
<h3><span id="myisam与innodb关于锁方面的区别">MyISAM与InnoDB关于锁方面的区别</span></h3><p>Ø MyISAM默认用的是表级锁，不支持行级锁</p>
<p>Ø InnoDB默认用的是行级锁，也支持表级锁</p>
<p>MySql客户端中一个Tab（标签页）就是一个Session</p>
<p><img src="/2020/03/23/database/clip_image018.jpg"></p>
<p>两个表除了引擎都一样</p>
<p>使用MyISAM引擎的时候，对一个表进行查询等操作的时候会加上数据的读锁，其他Session进行增删改的时候会加一个表级别的写锁，当读锁未被释放的时候，另外一个Session想要给表加上写锁就会被阻塞。</p>
<p>同理上写锁的时候没办法再上读锁，上写锁后也不能再上写锁。</p>
<p>如果在执行读操作后加上for update，其他读的操作也会被block。</p>
<p>InnoDB是二段锁，且默认打开autocommit。</p>
<p><img src="/2020/03/23/database/clip_image019.png"></p>
<p>两种方法都可以。</p>
<p>Set autocommit只对当前Session有用。</p>
<p><img src="/2020/03/23/database/clip_image021.jpg"></p>
<p>上共享锁后不能修改数据但是同样可以读数据（同一行）</p>
<p>当不走索引的时候，InnoDB也会锁住整张表，此时用表级锁。</p>
<p><img src="/2020/03/23/database/clip_image023.jpg"></p>
<p>X排他锁：增删改以及Select for update的时候。</p>
<p>S共享锁：读操作</p>
<h4><span id="myisam适合的场景">MyISAM适合的场景 √</span></h4><ul>
<li><p>频繁执行全表count语句</p>
</li>
<li><p>对数据进行增删改的频率不高，查询非常频繁</p>
</li>
<li><p>没有事务</p>
</li>
</ul>
<h4><span id="innodb适用的场景">InnoDB适用的场景 √</span></h4><ul>
<li><p>数据库增删改查都相当频繁</p>
</li>
<li><p>可靠性要求比较高，要求支持事务</p>
</li>
</ul>
<h4><span id="数据库锁的分类-">数据库锁的分类：-</span></h4><ul>
<li>按锁的粒度划分，可分为表级锁、行级锁、页级锁</li>
<li>按锁级别划分，可分为共享锁、排它锁</li>
<li>按加锁方式划分，可分为自动锁、显式锁</li>
<li>按操作划分，可分为DML锁、DDL锁</li>
<li>按使用方式划分，可分为乐观锁、悲观锁</li>
</ul>
<p><strong>DML(Data Manipulation Language)数据操纵语言</strong>：</p>
<p> 适用范围：对数据库中的数据进行一些简单操作，如insert,delete,update,select等.</p>
<p> <strong>DDL(Data Definition Language)数据定义语言：</strong><br> 适用范围：对数据库中的某些对象(例如，database,table)进行管理，如Create,Alter和Drop.truncate</p>
<p>多Session之间的互锁就是悲观锁的实现。</p>
<p><strong>乐观锁不使用数据库提供的锁机制</strong></p>
<ul>
<li>一般实现的两种方式：版本号和时间戳</li>
</ul>
<p>​	乐观锁加入了版本标识</p>
<p>​	<img src="/2020/03/23/database/clip_image025.jpg"></p>
<p>​	程序1：</p>
<p>​	<img src="/2020/03/23/database/clip_image027.jpg"></p>
<p>​	先执行</p>
<p>​	程序2：</p>
<p>​	<img src="/2020/03/23/database/clip_image029.jpg"></p>
<h3><span id="数据库事务的四大特性">数据库事务的四大特性</span></h3><p>ACID：</p>
<ul>
<li><p>原子性Atomic：<strong>事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败，就像原子一样不可分割；</strong></p>
</li>
<li><p>一致性Consistency：<strong>事务结束后系统状态是一致的；事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。</strong></p>
</li>
<li><p>隔离性Isolation：<strong>并发执行的事务彼此无法看到对方的中间状态；</strong></p>
</li>
<li><p>持久性Durability：<strong>事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</strong></p>
</li>
</ul>
<h3><span id="事务隔离级别以及各级别下并发访问问题">事务隔离级别以及各级别下并发访问问题</span></h3><h4><span id="1-更新丢失">1. 更新丢失</span></h4><p>Mysql所有事务隔离级别在数据库层面上均可避免</p>
<p><img src="/2020/03/23/database/clip_image031.jpg"></p>
<h4><span id="2-脏读读取未提交数据">2. 脏读（读取未提交数据）</span></h4><p>A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。</p>
<p><img src="/2020/03/23/database/clip_image032.png">Read-committed事务隔离级别及以上可以避免</p>
<p>通过</p>
<p><img src="/2020/03/23/database/clip_image033.png"></p>
<p>可以查到事务的隔离级别</p>
<p>设置事务隔离级别</p>
<p><img src="/2020/03/23/database/clip_image035.jpg">设置成最低的事务隔离级别</p>
<p>然后Session1操作</p>
<p>’ <img src="/2020/03/23/database/clip_image037.jpg"></p>
<p>Session2操作</p>
<p><img src="/2020/03/23/database/clip_image039.jpg"></p>
<p>此时Session1还未提交</p>
<p>然后Session1进行回滚，然后再查询</p>
<p><img src="/2020/03/23/database/clip_image041.jpg"></p>
<p>金额变成1000.</p>
<p>但是Session2以900位底进行操作</p>
<p><img src="/2020/03/23/database/clip_image043.jpg"></p>
<p>导致金额变成了1100。</p>
<p>但是应该有1200的。</p>
<p>只需要把事务级别设置成read commited以上就可以了</p>
<p>然后Session1进行红框操作</p>
<p><img src="/2020/03/23/database/clip_image045.jpg"></p>
<p>然后此时Session1并未提交，然后</p>
<p>Session2进行查询操作</p>
<p><img src="/2020/03/23/database/clip_image047.jpg"></p>
<p>此时Session2读到的值是1100（还未修改的数据）</p>
<p>可以避免脏读</p>
<h4><span id="3-不可重复读一个事务范围内两个相同的查询却返回了不同数据">3. 不可重复读（一个事务范围内两个相同的查询却返回了不同数据）</span></h4><p>事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。</p>
<p><img src="/2020/03/23/database/clip_image048.png"></p>
<p>Repeatable-read事务隔离级别以上可以避免</p>
<p>Session1：</p>
<p><img src="/2020/03/23/database/clip_image049.png"></p>
<p>Session2：</p>
<p><img src="/2020/03/23/database/clip_image051.jpg"></p>
<p>存入数据后发现已经为1600了</p>
<p>此时</p>
<p>Session1进行读取操作</p>
<p><img src="/2020/03/23/database/clip_image053.jpg"></p>
<p>由于设置了read-committed避免了脏读，因此还是1300</p>
<p>然后</p>
<p>Session2提交修改</p>
<p><img src="/2020/03/23/database/clip_image055.jpg"></p>
<p>此时，Session1再次读取</p>
<p>发现balance变成了1600</p>
<p><img src="/2020/03/23/database/clip_image057.jpg"></p>
<p>这就是所谓的不可重复读，即不可重复读，是指在数据库访问中，一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1">事务</a>范围内两个相同的查询却返回了不同数据。</p>
<h5><span id="解决方法">解决方法：</span></h5><p>将事务隔离级别改成：可重复读</p>
<p><img src="/2020/03/23/database/clip_image059.jpg"></p>
<p>然后此时：</p>
<p>Session1和Session2都开启事务</p>
<p>Session1读取账户</p>
<p><img src="/2020/03/23/database/clip_image060.png"></p>
<p>Session2：存入400</p>
<p><img src="/2020/03/23/database/clip_image062.jpg"></p>
<p>但是并未提交</p>
<p>此时</p>
<p>Session1读取</p>
<p><img src="/2020/03/23/database/clip_image064.jpg"></p>
<p>然后Session2进行提交操作</p>
<p>Commit</p>
<p>Session1再次进行查询操作</p>
<p><img src="/2020/03/23/database/clip_image066.jpg"></p>
<p>即使此时读取的是1600，但是再去做提交还是正确的</p>
<p><img src="/2020/03/23/database/clip_image068.jpg"></p>
<h4><span id="4-幻读前后多次读取数据总量不一致">4. 幻读：（前后多次读取，数据总量不一致）</span></h4><p><img src="/2020/03/23/database/clip_image069.png"></p>
<p>Serializable事务隔离级别可避免</p>
<p>Session1使用当前读读取整表数据</p>
<p><img src="/2020/03/23/database/clip_image071.jpg"></p>
<p>Session2进行插入操作</p>
<p><img src="/2020/03/23/database/clip_image073.jpg"></p>
<p>然后commit</p>
<p>紧接着Session1对所有余额进行更新</p>
<p><img src="/2020/03/23/database/clip_image074.png"></p>
<p>结果却更新了新插入的数据</p>
<p>事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。</p>
<p>把隔离级别改成Serializable后，所有sql操作都会加上锁，即使不加上lock in share mode；</p>
<p><img src="/2020/03/23/database/clip_image076.jpg"></p>
<h3><span id="innodb可重复读隔离级别下如何避免幻读">InnoDB可重复读隔离级别下如何避免幻读</span></h3><p>Ø 表象：快照读（非阻塞读）–伪MVCC</p>
<p>Ø 内在：next-key锁（行锁+gap锁）</p>
<h4><span id="当前读">当前读</span></h4><p>Select…lock in share mode（共享锁）, select…for update</p>
<p>Update, delete, insert</p>
<p>其余都是加上排他锁</p>
<p>读取的是记录的最新版本，并且读取后还需保证其他并发事务不能修改当前事务，对读取的事务加锁。</p>
<p><img src="/2020/03/23/database/clip_image078.jpg"></p>
<h4><span id="快照读">快照读</span></h4><p>不加锁的非阻塞读，select（不在Serializable级别下才成立）</p>
<p>在Serializable下是串行读，所以快照读退化成当前读。</p>
<h5><span id="rc级别下">RC级别下</span></h5><p>Session1：（RC）</p>
<p><img src="/2020/03/23/database/clip_image079.png"></p>
<p>Session2中</p>
<p><img src="/2020/03/23/database/clip_image081.jpg"></p>
<p>在Session1中用当前读:</p>
<p><img src="/2020/03/23/database/clip_image083.jpg"></p>
<p>快照读</p>
<p><img src="/2020/03/23/database/clip_image084.png"></p>
<p>快照读已经为600</p>
<p><strong>在RC下，快照读和当前读的效果是一样的</strong></p>
<h5><span id="在rr级别下">在RR级别下</span></h5><p>在Session3中先使用快照读</p>
<p><img src="/2020/03/23/database/clip_image086.jpg"></p>
<p><img src="/2020/03/23/database/clip_image087.png"></p>
<p>在Session4中将余额改成300</p>
<p><img src="/2020/03/23/database/clip_image089.jpg"></p>
<p>Session3当前读：</p>
<p><img src="/2020/03/23/database/clip_image091.jpg"></p>
<p>更新成300</p>
<p>快照读：</p>
<p><img src="/2020/03/23/database/clip_image093.jpg"></p>
<p>快照读还是600</p>
<p>有没有可能在快照读下读到最新的数据呢？ 可以！</p>
<p>在Session3中先不做查询，先在Session4中对balance更新</p>
<p><img src="/2020/03/23/database/clip_image095.jpg"></p>
<p>然后在Session3中使用当前读和快照读都是0</p>
<h4><span id="gap锁">Gap锁</span></h4><p>Gap是索引树中插入数据的空隙，gap lock锁定一个范围，但是不包括数据本身。</p>
<p>目的是为了防止同一事务的两次当前读出现幻读的情况。</p>
<p>在RR和Serializable下都默认支持Gap锁</p>
<h5><span id="1-主键或者唯一键">1. 主键或者唯一键</span></h5><p>在RR下无论删改查当前读若用到主键或者唯一键会用到gap锁吗？</p>
<p>Ø 如果where条件全部命中，则不会用Gap锁，只会加记录锁</p>
<p>全部命中即精确查询，全部条件都在数据库中存在。</p>
<p>由于全部命中，不会出现幻读情况。就不需要加Gap锁。（因为新增的数据肯定在where范围之外，（where里面是唯一键或者主键））</p>
<p><img src="/2020/03/23/database/clip_image096.png"></p>
<p>由于id是唯一键。因此delete会走id这列的索引进行where条件的过滤。</p>
<p>在找到id&#x3D;9的记录会将id&#x3D;9的数据加上行锁(record lock),会根据读到的name作为主键索引，即密集索引，然后将name&#x3D;d对应的主键索引项也加上record lock（排他锁）。</p>
<p><strong>为什么将主键索引也加锁呢</strong></p>
<p>如果此时有其他事务更新name&#x3D;d的id为90，由于没有锁，该事务无法感知此次更新，违背了同一记录上的更新或者删除需要串行执行的约束。</p>
<p>创建tb表</p>
<p><img src="/2020/03/23/database/clip_image097.png"></p>
<p>其中ID为4 、7 和 8的数据不存在</p>
<p><img src="/2020/03/23/database/clip_image098.png"></p>
<p>此时两个Session的事务隔离级别均为RR</p>
<h6><span id="全部命中">全部命中</span></h6><p>Session1：</p>
<p><img src="/2020/03/23/database/clip_image099.png"></p>
<p>怎么证明是走唯一索引呢？用explain</p>
<p><img src="/2020/03/23/database/clip_image101.jpg"></p>
<p>如果有gap锁的话9周围的间隙将被锁起来</p>
<p>如果在别的事务中加入id&#x3D;10的数据是会被Blocked住</p>
<p>在Session1未提交时</p>
<p>Session2：</p>
<p><img src="/2020/03/23/database/clip_image102.png"></p>
<p>执行成功，因为不加gap锁。</p>
<p>Ø 如果where条件部分命中或者全不命中，则会加Gap锁</p>
<h6><span id="全不命中">全不命中</span></h6><p>我们只需要删除一个不存在的记录即可（我们在Session1删除7，Session2插入8试试看）</p>
<p><strong>在Session1：</strong></p>
<p>删除不存在的值</p>
<p><img src="/2020/03/23/database/clip_image103.png"></p>
<p><strong>Session2：</strong></p>
<p>插入不存在的值</p>
<p><img src="/2020/03/23/database/clip_image104.png"></p>
<p>然后被blocked</p>
<h6><span id="部分命中">部分命中</span></h6><p>Session1：</p>
<p><img src="/2020/03/23/database/clip_image105.png"></p>
<p><img src="/2020/03/23/database/clip_image106.png"></p>
<p>Session1未提交时</p>
<p>Session2进行插入操作</p>
<p><img src="/2020/03/23/database/clip_image107.png"></p>
<p>插入4成功了，小于5的数据并未加锁</p>
<p>（插入5到9的数据会被锁住）</p>
<p>插入7的时候被blocked住了</p>
<p>插入8也被锁住</p>
<p>插入10就没被锁住</p>
<h6><span id="如果全命中">如果全命中</span></h6><p>Session1</p>
<p><img src="/2020/03/23/database/clip_image109.jpg"></p>
<p>此时Session2插入7和8均成功执行（不加Gap锁）</p>
<p><img src="/2020/03/23/database/clip_image111.jpg"></p>
<p>Gap范围有那么多，但是只会对(6,9] (9,11]的gap上锁</p>
<p>Gap锁锁住左开右闭的区间</p>
<p><img src="/2020/03/23/database/clip_image113.jpg"></p>
<p>Gap锁是用来防止插入的</p>
<p>如图会对(6-9] (9-11]gap区间上锁</p>
<p><strong>但是还要考虑主键的值才能最终判断。</strong></p>
<h5><span id="非唯一索引和不走索引的当前读下">非唯一索引和不走索引的当前读下</span></h5><h6><span id="非唯一索引">非唯一索引</span></h6><p>创建表</p>
<p><img src="/2020/03/23/database/clip_image114.png"></p>
<p><strong>和图中的案例是一致的，gap锁锁住(6,9] (9,11]</strong></p>
<p><img src="/2020/03/23/database/clip_image115.png"></p>
<p>Session1：</p>
<p><img src="/2020/03/23/database/clip_image116.png"></p>
<p>Session2：</p>
<p><img src="/2020/03/23/database/clip_image117.png"></p>
<p>需要等待Session1提交或者回滚</p>
<p>此时插入5 7 12的情况：</p>
<p>5成功</p>
<p>7失败</p>
<p>12成功</p>
<p>临界情况</p>
<p>插入6和11</p>
<p>我们可以看到此时表里id为6的行的name的值为c</p>
<p><img src="/2020/03/23/database/clip_image118.png"></p>
<p>根据字母表顺序b&lt;c&lt;d</p>
<p><img src="/2020/03/23/database/clip_image119.png"></p>
<p>插入成功</p>
<p>插入主键为dd，id为6的值失败</p>
<p><img src="/2020/03/23/database/clip_image121.jpg"></p>
<p>由于主键bb按字母顺序不在6-11内因此没有被blocked</p>
<p>相反 dd在6-11内因此被blokced</p>
<h6><span id="不走索引">不走索引</span></h6><p><img src="/2020/03/23/database/clip_image122.png"></p>
<p>所有gap均被锁住</p>
<p>创建表</p>
<p><img src="/2020/03/23/database/clip_image123.png">c</p>
<p><img src="/2020/03/23/database/clip_image124.png"></p>
<p>Session1:</p>
<p><img src="/2020/03/23/database/clip_image125.png"></p>
<p>Session2:</p>
<p><img src="/2020/03/23/database/clip_image127.jpg"></p>
<h3><span id="rc-rr级别下的innodb的非阻塞读如何实现">RC、RR级别下的InnoDB的非阻塞读如何实现</span></h3><p>Ø 数据行里的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段</p>
<p><em>第一个是事务ID，第二个是rollback指针，第三个是行号（可以作为隐藏主键（如果没有主键和唯一键）），此外还有其他标志，比如说删除一行数据不是真的将其删除，而是将删除的标志位更改。</em></p>
<p>Ø Undo日志</p>
<p><em>存储老版数据</em></p>
<p>Ø Read view</p>
<p><img src="/2020/03/23/database/clip_image129.jpg"></p>
<p>分为Insert Undo log和update undo log</p>
<p>Insert Undo log事务对insert产生的undo log，只在事务回滚的时候需要，并且在事务提交的时候丢弃。</p>
<p>Update undo log，事务delete和update产生的undo log，不仅在回滚的时候需要，快照读的时候也需要所以不能随便删除，只有在快照中不涉及该记录该日志才会被xx线程删除。</p>
<p>Read view主要做可见性判断的</p>
<p>当我们执行快照读Select的时候，针对我们查询的数据，创建出一个read view来决定当前事务能看到的是哪个版本的数据。Read view 遵循一个可见性算法，将数据的DB_TRX_ID数据取出来与系统其它活跃事务id做对比，如果大于或者等于这些id的话就通过db_roll_ptr指针去取出undo log上一层的DB_TRX_ID直到小于这些活跃事务id为止。这样就保证我们获取数据的版本是最稳定的版本。（越新开启的事务，它的ID是越大的）</p>
<p>在RR级别下Session在start transaction之后的第一条快照读后创建一个快照即read view会将当前系统中活跃的事务记录起来，此后调用快照读的话还是调用同一个read view。</p>
<p>在RC级别下，事务中每条Select语句每次都会创建一次新的快照</p>
<p>读取事务时候的非阻塞就是MVCC（多版本并发控制）</p>
<p>InnoDB的非阻塞读机制是伪MVCC（读写不冲突），并没有实现多版本共存，undo log内容只是串行化的结果，记录多个事务过程不属于多版本共存。</p>
<h2><span id="关键语法">关键语法</span></h2><h4><span id="group-by">GROUP BY</span></h4><p>满足Select字句中的列名必须为分组列或列函数（只对一张表成立）</p>
<p>列函数对于group by字句定义的每个组各返回一个结果</p>
<p><img src="/2020/03/23/database/clip_image002-1584950982263.jpg"></p>
<p><img src="/2020/03/23/database/clip_image004-1584950982263.jpg"></p>
<p><img src="/2020/03/23/database/clip_image006-1584950982264.jpg"> </p>
<p><img src="/2020/03/23/database/image-20200323162145595.png"></p>
<p>查询所有同学的学号，课程数，总成绩</p>
<p><img src="/2020/03/23/database/clip_image009.png"></p>
<p><img src="/2020/03/23/database/clip_image011.jpg"></p>
<p>Where一定要在group by前面</p>
<h4><span id="having">HAVING</span></h4><p>Ø 通常与GROUP BY子句一起使用</p>
<p>Ø WHERE过滤行，HAVING过滤组</p>
<p>Ø 出现在同一sql的顺序：WHERE-&gt;GROUP BY-&gt;HAVING</p>
<p><img src="/2020/03/23/database/clip_image012.png"></p>
<p><img src="/2020/03/23/database/clip_image013.png"></p>
<h4><span id="countsummaxminavg">COUNT,SUM,MAX,MIN,AVG</span></h4><h2><span id="理论范式">理论范式</span></h2><p><img src="/2020/03/23/database/clip_image015.jpg" alt="范式"></p>
<h3><span id="1nf">1NF</span></h3><p>是指在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B">关系模型</a>中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，<strong>第一范式就是无重复的域</strong>(**原子项)**。</p>
<p>1NF是关系模式应具备的最起码的条件，如果数据库设计不能满足第一范式，就不能称为关系型数据库。关系数据库设计研究的关系规范化是在1NF之上进行的。</p>
<h3><span id="2nf">2NF</span></h3><p>第二范式要满足的条件：<font color="red">首先要满足第一范式，其次每一个非主属性要完全函数依赖于候选键，或者是主键。</font>也就是说，每个非主属性是由整个主键函数决定的，而不能有主键的一部分来决定。</p>
<h3><span id="3nf">3NF</span></h3><p>如果关系模式R是2NF，且关系模式R（U,F）中的所有非主属性对任何候选关键字都不存在传递依赖，则称关系R是属于第三范式。</p>
<p>第三范式（3NF）；符合2NF，并且，消除传递依赖。</p>
<h3><span id="其它范式">其它范式</span></h3><p>第四范式：要求把同一表内的多对多关系删除。</p>
<p>第五范式：从最终结构重新建立原始结构。</p>
<p>BC范式（BCNF）：符合3NF，并且，主属性不依赖于主属性。若关系模式R属于第一范式，且每个属性都不传递依赖于键码，则R属于BC范式。</p>
<h3><span id="优缺点">优缺点</span></h3><p>规范化的优点是明显的，它避免了大量的数据冗余，节省了存储空间，保持了数据的一致性。当一个库里的数据经常发生变化时，达到3NF的库可以使用户不必在超过两个以上的地方更改同一个值。那么是不是只要把所有的表都规范为3NF后，数据库的设计就是最优的呢?这可不一定。范式越高意味着表的划分更细，一个数据库中需要的表也就越多，用户不得不将原本相关联的数据分摊到多个表中。当用户同时需要这些数据时只能采用连接表的形式将数据重新合并在一起。同时把多个表联接在一起的花费是巨大的，尤其是当需要连接的两张或者多张表数据非常庞大的时候，表连接操作几乎是一个噩梦，这严重地降低了系统运行性能</p>
<h2><span id="数据库连接">数据库连接</span></h2><p><img src="/2020/03/23/database/clip_image017.jpg" alt="数据库连接"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/DarkAngel1228/article/details/80004222?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1">https://blog.csdn.net/DarkAngel1228/article/details/80004222?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1</a> 主从</p>
</div></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'd154fff64901622afbb6',
  clientSecret: '5b3f1d58c331b54703e4477e1f8fa1e42e9c1082',
  repo: 'Disda-coding.github.io',
  owner: 'Disda-coding',
  admin: ['Disda-coding'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Disda.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> </a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Disda.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>