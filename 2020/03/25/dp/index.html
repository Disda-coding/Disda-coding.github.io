<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="简单记录一些笔记"><title>动态规划集合 | Disda</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">动态规划集合</h1><a id="logo" href="/.">Disda</a><p class="description">Disda’s Dairy</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">动态规划集合</h1><div class="post-content"><p>摘录了一些经典的动态规划题</p>
<a id="more"></a>

<!-- toc -->

<ul>
<li><a href="#基本dp问题">基本DP问题：</a><ul>
<li><a href="#70-climbing-stairs">70. Climbing Stairs √</a></li>
<li><a href="#120-triangle">120. Triangle √</a></li>
<li><a href="#53-maximum-subarray">53. Maximum Subarray √</a></li>
<li><a href="#303-range-sum-query-immutable">303. Range Sum Query - Immutable √</a></li>
<li><a href="#343-integer-break">343. Integer Break √</a></li>
</ul>
</li>
<li><a href="#矩形dp问题">矩形DP问题</a><ul>
<li><a href="#62-unique-paths">62. Unique Paths √</a></li>
<li><a href="#64-minimum-path-sum">64. Minimum Path Sum √</a></li>
<li><a href="#63-unique-paths-ii">63. Unique Paths II √</a></li>
<li><a href="#221-maximal-square-">221. Maximal Square -</a></li>
</ul>
</li>
<li><a href="#序列类动态规划问题">序列类动态规划问题</a><ul>
<li><a href="#300-longest-increasing-subsequence">300. Longest Increasing Subsequence √</a></li>
<li><a href="#leetcode-第-256-号问题粉刷房子">LeetCode 第 256 号问题：粉刷房子 √</a></li>
<li><a href="#198-house-robber">198. House Robber √</a></li>
<li><a href="#leetcode-第-265-号问题粉刷房子ii">LeetCode 第 265 号问题：粉刷房子II √</a></li>
<li><a href="#213-house-robber-ii">213. House Robber II √</a></li>
<li><a href="#413-arithmetic-slices">413. Arithmetic Slices √</a></li>
<li><a href="#279-perfect-squares">279. Perfect Squares √</a></li>
<li><a href="#91-decode-ways">91. Decode Ways ×</a></li>
</ul>
</li>
<li><a href="#双序列类动态规划字符匹配类">双序列类动态规划：字符匹配类</a><ul>
<li><a href="#1143-longest-common-subsequence-">1143. Longest Common Subsequence -</a></li>
<li><a href="#72-edit-distance">72. Edit Distance √</a></li>
<li><a href="#44-wildcard-matching-">44. Wildcard Matching -</a></li>
<li><a href="#10-regular-expression-matching">10. Regular Expression Matching ×</a></li>
<li><a href="#97-interleaving-string">97. Interleaving String ×</a></li>
</ul>
</li>
<li><a href="#概率dp问题">概率DP问题</a><ul>
<li><a href="#4-信件错排">4. 信件错排 ×</a></li>
<li><a href="#5-母牛生产">5. 母牛生产 √</a></li>
</ul>
</li>
<li><a href="#各种game集合">各种Game集合</a><ul>
<li><a href="#1025-divisor-game">1025. Divisor Game ×</a></li>
<li><a href="#877-stone-game">877. Stone Game</a></li>
</ul>
</li>
<li><a href="#股票问题状态机">股票问题（状态机）</a><ul>
<li><a href="#leetcode-121-best-time-to-buy-and-sell-stock">Leetcode 121 Best Time to Buy and Sell Stock √</a></li>
<li><a href="#leetcode-122-best-time-to-buy-and-sell-stock-ii">Leetcode 122 Best Time to Buy and Sell Stock II √</a></li>
<li><a href="#leetcode-123-best-time-to-buy-and-sell-stock-iii">Leetcode 123 Best Time to Buy and Sell Stock III √</a></li>
<li><a href="#leetcode-188-best-time-to-buy-and-sell-stock-iv">Leetcode 188 Best Time to Buy and Sell Stock IV ×</a></li>
<li><a href="#leetcode-309-best-time-to-buy-and-sell-stock-with-cooldown">Leetcode 309 Best Time to Buy and Sell Stock with Cooldown √</a></li>
<li><a href="#leetcode-714-best-time-to-buy-and-sell-stock-with-transcation-fee">Leetcode 714 Best Time to Buy and Sell Stock with Transcation Fee √</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h1><span id="基本dp问题">基本DP问题：</span></h1><h2><span id="70-climbing-stairs">70. Climbing Stairs √</span></h2><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例</strong> <strong>1</strong>：</p>
<p> 输入：2<br> 输出：2<br> 解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p><strong>示例</strong> <strong>2</strong>：</p>
<p> 输入：3<br> 输出：3<br> 解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="120-triangle">120. Triangle √</span></h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br> ]</p>
<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p><strong>说明：</strong></p>
<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p>二维dp解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][]dp;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = triangle.size();</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">           dp[len-<span class="number">1</span>][i] = triangle.get(len-<span class="number">1</span>).get(i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">               dp[i][j]=triangle.get(i).get(j)+Math.min(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如何降维打击呢？如果看过背包问题就不难回答了。dp[i][j]&lt;—dp[i+1][j] , dp[i+1][j+1]。</p>
<p>因此正序遍历的话只会改变dp[i]的值，对dp[i+1]的值没有任何影响，所以我们降维打击应该采取正向遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = triangle.get(triangle.size()-<span class="number">1</span>).size();</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i]=triangle.get(len-<span class="number">1</span>).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle.get(i).size();j++)</span><br><span class="line">                dp[j]=Math.min(dp[j],dp[j+<span class="number">1</span>])+triangle.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2><span id="53-maximum-subarray">53. Maximum Subarray √</span></h2><p>给定一个整数数组 <em>nums</em> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例</strong>:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br> 输出: 6<br> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>**进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i]=nums[i]&gt;nums[i]+dp[i-<span class="number">1</span>]?nums[i]:nums[i]+dp[i-<span class="number">1</span>];</span><br><span class="line">            res=Math.max(dp[i],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实可以多开1个空间去优化代码长度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">        dp[i]=Math.max(dp[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>],nums[i-<span class="number">1</span>]);</span><br><span class="line">        res = res&lt;dp[i]?dp[i]:res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到dp[i]其实依赖只于dp[i-1]，因此我们只需要两个变量足以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curMax = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            curMax = Math.max(nums[i],nums[i]+curMax);</span><br><span class="line">            max = Math.max(max,curMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2><span id="303-range-sum-query-immutable">303. Range Sum Query - Immutable √</span></h2><p>Given an integer array <em>nums</em>, find the sum of the elements between indices <em>i</em> and <em>j</em> (<em>i</em> ≤ <em>j</em>), inclusive.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> rec=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">        rec+=i;</span><br><span class="line">        res[j]=rec;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> res[j]- (i-<span class="number">1</span>&gt;=<span class="number">0</span>?res[i-<span class="number">1</span>]:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="343-integer-break">343. Integer Break √</span></h2><p>Given a positive integer <em>n</em>, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 36</span><br><span class="line">Explanation: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[]=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">            dp[i]=Math.max(Math.max((i-j)*dp[j],(i-j)*j),dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="矩形dp问题">矩形DP问题</span></h1><h2><span id="62-unique-paths">62. Unique Paths √</span></h2><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="clip_image001.png" alt><br> Above is a 7 x 3 grid. How many possible unique paths are there?</p>
<p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p>
<p><strong>说明：</strong> <em>m</em> 和 <em>n</em> 的值均不超过 100。</p>
<p><strong>示例</strong> <strong>1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> <strong>2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 7, n &#x3D; 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> imt <span class="title">umiquePaths</span><span class="params">(imt m, imt n)</span> </span>&#123;</span><br><span class="line">    imt[][] dp = mew imt[n][m];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (imt i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (imt j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (imt i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (imt j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    returm dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>降维打击：</p>
<p>还是分析一下dp[i][j]依赖于dp[i][j]当前行的左边元素和dp[i-1][j]上一行的元素，因此应该选择正序遍历以实时获得当前行左边元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2><span id="64-minimum-path-sum">64. Minimum Path Sum √</span></h2><p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>
<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m=grid.length,n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp[<span class="number">0</span>],Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++) dp[i][<span class="number">0</span>]=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dp[i][j]=grid[i-<span class="number">1</span>][j-<span class="number">1</span>]+Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="63-unique-paths-ii">63. Unique Paths II √</span></h2><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p><strong>现在考虑网格中有障碍物</strong>。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="dp/clip_image001-1585104415889.png" alt="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"></p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p><strong>示例</strong> <strong>1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid.length == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span> ? <span class="number">0</span> : dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[i][j] = obstacleGrid[i][j] == <span class="number">1</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="221-maximal-square-">221. Maximal Square -</span></h2><p>在一个由 <em>0</em> 和 <em>1</em> 组成的二维矩阵内，找到只包含 <em>1</em> 的最大正方形，并返回其面积。</p>
<p><strong>示例</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p>咋一看是dfs其实不然，试了很多方法都没办法真正解出来。</p>
<p>其实正方形大小计算就是看它左右还有斜下角是不是1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;row ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;col ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>) dp[i][j]=matrix[i][j]==<span class="string">'1'</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j]==<span class="string">'1'</span>)</span><br><span class="line">                dp[i][j]=min(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>],dp[i][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">            res=res&gt;dp[i][j]*dp[i][j]?res:dp[i][j]*dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    a=a&gt;b?b:a;</span><br><span class="line">    a=a&gt;c?c:a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="序列类动态规划问题">序列类动态规划问题</span></h1><h2><span id="300-longest-increasing-subsequence">300. Longest Increasing Subsequence √</span></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p><strong>示例</strong>:</p>
<p> 输入: [10,9,2,5,3,7,101,18]<br> 输出: 4<br> 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p>
<p><strong>说明</strong>:</p>
<p>·  可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</p>
<p>·  你算法的时间复杂度应该为 O(n2) 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">                    dp[i]=Math.max(dp[i],<span class="number">1</span>+dp[j]);                </span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2><span id="leetcode-第-256-号问题粉刷房子">LeetCode 第 256 号问题：粉刷房子 √</span></h2><p>注意：本题为 LeetCode 的付费题目，需要开通会员才能解锁查看与提交代码。</p>
<p>题目描述</p>
<p>假如有一排房子，共 <em>n</em> 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>
<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 <em>n x 3</em> 的矩阵来表示的。</p>
<p>例如，<code>costs[0][0]</code>表示第 0 号房子粉刷成红色的成本花费；<code>costs[1][2]</code>表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。</p>
<p><strong>注意：</strong></p>
<p>所有花费均为正整数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[17,2,17],[16,16,5],[14,3,19]]</span><br><span class="line">输出: 10</span><br><span class="line">解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。</span><br><span class="line">     最少花费: 2 + 5 + 3 &#x3D; 10。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">paint</span><span class="params">(<span class="keyword">int</span>[][] cost)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(cost.length==<span class="number">0</span>||cost[<span class="number">0</span>].length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n=cost.length,m=cost[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dp[i][j]=Math.min(dp[i-<span class="number">1</span>][(j+<span class="number">1</span>)%m],dp[i-<span class="number">1</span>][(j+<span class="number">2</span>)%m])+cost[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2><span id="198-house-robber">198. House Robber √</span></h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money &#x3D; 1) and then rob house 3 (money &#x3D; 3).</span><br><span class="line">             Total amount you can rob &#x3D; 1 + 3 &#x3D; 4.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[] =<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;len;i++)&#123;</span><br><span class="line">        dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="leetcode-第-265-号问题粉刷房子ii">LeetCode 第 265 号问题：粉刷房子II √</span></h2><p>注意：本题为 LeetCode 的付费题目，需要开通会员才能解锁查看与提交代码。</p>
<p>题目描述</p>
<p>假如有一排房子，共 <em>n</em> 个，每个房子可以被粉刷成 <em>k</em> 种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>
<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 <em>n x k</em> 的矩阵来表示的。</p>
<p>例如，<code>costs[0][0]</code> 表示第 0 号房子粉刷成 0 号颜色的成本花费；<code>costs[1][2]</code> 表示第 1 号房子粉刷成 2 号颜色的成本花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。</p>
<p><strong>注意：</strong></p>
<p>所有花费均为正整数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,5,3],[2,9,4]]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 将 0 号房子粉刷成 0 号颜色，1 号房子粉刷成 2 号颜色。最少花费: 1 + 4 &#x3D; 5; </span><br><span class="line">     或者将 0 号房子粉刷成 2 号颜色，1 号房子粉刷成 0 号颜色。最少花费: 3 + 2 &#x3D; 5.</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br> 您能否在 <em>O(nk)</em> 的时间复杂度下解决此问题？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCostII</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (costs.length == <span class="number">0</span> || costs[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = costs.length, k = costs[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">        Arrays.fill(dp[i],Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; k; ++m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m != j) &#123;</span><br><span class="line">                    dp[i][m] = Math.min(dp[i][m], dp[i - <span class="number">1</span>][j] + costs[i-<span class="number">1</span>][m] );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        result = Math.min(result, dp[n][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这是可以优化的，我们只需要在第 i - 1 个位置的状态中找到最小值和次小值，在选择第 i 个房子的颜色的时候，我们看当前颜色是不是和最小值的颜色相重，不是的话直接加上最小值，如果相重的话，我们就加上次小值，这样一来，我们把两个嵌套的循环，拆开成两个平行的循环，时间复杂度降至 O(n*k)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCostII2</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (costs.length == <span class="number">0</span> || costs[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = costs.length, k = costs[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = costs[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// min1 表示的是最小值，min2 表示的是次小值</span></span><br><span class="line">        <span class="keyword">int</span> min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; k; ++l) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min1 &gt; dp[i - <span class="number">1</span>][l]) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = dp[i - <span class="number">1</span>][l];</span><br><span class="line">                minIndex = l;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min2 &gt; dp[i - <span class="number">1</span>][l]) &#123;</span><br><span class="line">                min2 = dp[i - <span class="number">1</span>][l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minIndex != j) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], min1 + costs[i][j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], min2 + costs[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        result = Math.min(result, dp[n - <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="213-house-robber-ii">213. House Robber II √</span></h2><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle.</strong> That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money &#x3D; 2) and then rob house 3 (money &#x3D; 2),</span><br><span class="line">             because they are adjacent houses.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,len-<span class="number">2</span>),rob(nums,<span class="number">1</span>,len-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo==hi) <span class="keyword">return</span> nums[lo];</span><br><span class="line">    <span class="keyword">int</span> dp[]=<span class="keyword">new</span> <span class="keyword">int</span>[hi-lo+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=nums[lo];</span><br><span class="line">    dp[<span class="number">1</span>]=Math.max(nums[lo],nums[lo+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=lo+<span class="number">2</span>;i&lt;=hi;i++)&#123;</span><br><span class="line">        dp[i-lo]=Math.max(dp[i-<span class="number">1</span>-lo],dp[i-<span class="number">2</span>-lo]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[hi-lo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="413-arithmetic-slices">413. Arithmetic Slices √</span></h2><p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p>
<p>For example, these are arithmetic sequence:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure>

<p>The following sequence is not arithmetic.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure>

<p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p>
<p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p>
<p>The function should return the number of arithmetic slices in the array A.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]-A[i-<span class="number">1</span>]==A[i-<span class="number">1</span>]-A[i-<span class="number">2</span>])&#123;</span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:dp) res+=i;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2><span id="279-perfect-squares">279. Perfect Squares √</span></h2><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 12</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 &#x3D; 4 + 9.</span><br></pre></td></tr></table></figure>

<p>贪心失败 比如说12</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; squareList = list(n);</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> square : squareList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (square &gt; i) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - square] + <span class="number">1</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">list</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">1</span>,num=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">            res.add(num);</span><br><span class="line">             i++;</span><br><span class="line">             num=i*i;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2><span id="91-decode-ways">91. Decode Ways ×</span></h2><p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>

<p>Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> one = Integer.valueOf(s.substring(i-<span class="number">1</span>,i));</span><br><span class="line">            <span class="keyword">if</span>(one!=<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i]+=dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> two=Integer.valueOf(s.substring(i-<span class="number">2</span>,i));</span><br><span class="line">            <span class="keyword">if</span> (two &lt;= <span class="number">26</span>&amp;&amp;two&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1><span id="双序列类动态规划字符匹配类">双序列类动态规划：字符匹配类</span></h1><p>它的题目特征其实特别明显，比如：</p>
<p>·  输入是两个字符串，问是否通过一定的规则相匹配</p>
<p>·  输入是两个字符串，问两个字符串是否存在包含被包含的关系</p>
<p>·  输入是两个字符串，问一个字符串怎样通过一定规则转换成另一个字符串</p>
<p>·  输入是两个字符串，问它们的共有部分</p>
<p>可以画表格来解题</p>
<h2><span id="1143-longest-common-subsequence-">1143. Longest Common Subsequence -</span></h2><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长公共子序列。</p>
<p>一个字符串的 <em>子序列</em> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br> 例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p><strong>示例</strong> <strong>1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> <strong>2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> <strong>3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0。</span><br></pre></td></tr></table></figure>

<p>  画图可得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">   &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0             如果其中一个字符串是空串</span><br><span class="line">b   0             那么两个字符不存在公共子序列</span><br><span class="line">c   0             对应的子问题状态初始化为 0</span><br><span class="line">d   0</span><br><span class="line">e   0</span><br><span class="line">   &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0  1  1  1    text1 &#x3D; &quot;a&quot;  text2 &#x3D; &quot;a&quot; || text2 &#x3D; &quot;ac&quot; || text2 &#x3D; &quot;ace&quot;</span><br><span class="line">b   0             考虑当前状态 dp[i][j] 的时候        </span><br><span class="line">c   0             我们可以考虑子状态 dp[i - 1][j - 1]</span><br><span class="line">d   0                             dp[i][j - 1]</span><br><span class="line">e   0                             dp[i - 1][j]</span><br><span class="line">   &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0  1  1  1    </span><br><span class="line">b   0  1  1  1    text1 &#x3D; &quot;ab&quot;  text2 &#x3D; &quot;a&quot; || text2 &#x3D; &quot;ac&quot; || text2 &#x3D; &quot;ace&quot;</span><br><span class="line">c   0</span><br><span class="line">d   0</span><br><span class="line">e   0</span><br><span class="line">   &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0  1  1  1    </span><br><span class="line">b   0  1  1  1</span><br><span class="line">c   0  1  2  2    text1 &#x3D; &quot;abc&quot;  text2 &#x3D; &quot;a&quot; || text2 &#x3D; &quot;ac&quot; || text2 &#x3D; &quot;ace&quot;</span><br><span class="line">d   0             画到这里，不知道你有没有发现当当前的字符不相同时</span><br><span class="line">e   0                 dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i][j - 1])</span><br><span class="line">  &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0  1  1  1    </span><br><span class="line">b   0  1  1  1</span><br><span class="line">c   0  1  2  2</span><br><span class="line">d   0  1  2  2    text1 &#x3D; &quot;abcd&quot;  text2 &#x3D; &quot;a&quot; || text2 &#x3D; &quot;ac&quot; || text2 &#x3D; &quot;ace&quot;</span><br><span class="line">e   0</span><br><span class="line">   &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0  1  1  1    </span><br><span class="line">b   0  1  1  1</span><br><span class="line">c   0  1  2  2</span><br><span class="line">d   0  1  2  2    </span><br><span class="line">e   0  1  2  3    text1 &#x3D; &quot;abcde&quot;  text2 &#x3D; &quot;a&quot; || text2 &#x3D; &quot;ac&quot; || text2 &#x3D; &quot;ace&quot;</span><br><span class="line"></span><br><span class="line">3 就是我们要返回的答案</span><br></pre></td></tr></table></figure>



<p>在拆解问题中也说了，有两种情况，就是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果 str1(i) !&#x3D; str2(j):</span><br><span class="line">dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i][j - 1])</span><br><span class="line"></span><br><span class="line">如果 str1(i) &#x3D;&#x3D; str2(j):</span><br><span class="line">dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1)</span><br><span class="line"></span><br><span class="line">因为 dp[i - 1][j - 1] + 1 &gt;&#x3D; dp[i - 1][j] &amp;&amp; dp[i - 1][j - 1] + 1 &gt;&#x3D; dp[i][j - 1]</span><br><span class="line">所以第二项可以化简：</span><br><span class="line"></span><br><span class="line">如果 str1(i) &#x3D;&#x3D; str2(j):</span><br><span class="line">dp[i][j] &#x3D; dp[i - 1][j - 1] + 1</span><br></pre></td></tr></table></figure>

<p>讲道理，第二次做的时候不明白为什么和dp[i - 1][j - 1]有关。</p>
<p>其实是这样，比如说我们比abc和acc，要么最长的长度是ab和ac基础上+1，要么是abc和ac，要么是acc和ab。因为acc和abc以及ac和abc的匹配长度是一样的。所以abc和acc不能是ac基础上+1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = text1.length();</span><br><span class="line">    <span class="keyword">int</span> length2 = text2.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] textArr1 = text1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] textArr2 = text2.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length1; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= length2; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (textArr1[i - <span class="number">1</span>] == textArr2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.length(), n = s2.length();</span><br><span class="line">    <span class="keyword">if</span> (m &lt; n)  <span class="keyword">return</span> longestCommonSubsequence(s2, s1);</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">1</span>; i &lt; m; ++i, k ^= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) dp[k][j + <span class="number">1</span>] = <span class="number">1</span> + dp[k ^ <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[k][j + <span class="number">1</span>] = Math.max(dp[k ^ <span class="number">1</span>][j + <span class="number">1</span>], dp[k][j]);</span><br><span class="line">    <span class="keyword">return</span> dp[m % <span class="number">2</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">^是亦或</font></p>
<h2><span id="72-edit-distance">72. Edit Distance √</span></h2><p>给定两个单词 <em>word1</em> 和 <em>word2*，计算出将 *word1</em> 转换成 <em>word2</em> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>·  插入一个字符</p>
<p>·  删除一个字符</p>
<p>·  替换一个字符</p>
<p><strong>示例</strong> <strong>1:</strong></p>
<p>输入: word1 = “horse”, word2 = “ros”<br> 输出: 3<br> 解释:<br> horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br> rorse -&gt; rose (删除 ‘r’)<br> rose -&gt; ros (删除 ‘e’)</p>
<p><strong>示例</strong> <strong>2:</strong></p>
<p>输入: word1 = “intention”, word2 = “execution”<br> 输出: 5<br> 解释:<br> intention -&gt; inention (删除 ‘t’)<br> inention -&gt; enention (将 ‘i’ 替换为 ‘e’)<br> enention -&gt; exention (将 ‘n’ 替换为 ‘x’)<br> exention -&gt; exection (将 ‘n’ 替换为 ‘c’)<br> exection -&gt; execution (插入 ‘u’)</p>
<p>求什么就设什么</p>
<p>Dp[i][j]设为word1 的前i个字符和word2的前j个字符转换为相同字符串的最小费用</p>
<p>初始化条件矩阵（x轴设为i，y轴为j）</p>
<p>因为null-&gt;null h o r s e分别是0 1 2 3 4 5</p>
<p>且null-&gt;null r o s 分别是 0 1 2 3</p>
<p><img src="clip_image001-1585225322024.png" alt></p>
<p><strong>H和R</strong></p>
<p><img src="clip_image002.png" alt></p>
<p>此时黄色格子的值相当于是把h替换r是最小的</p>
<p>Min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</p>
<p>因此dp[i-1][j-1]+1代表替换操作</p>
<p><strong>HO</strong>和R-&gt;依赖以上一步的变化结果<strong>-&gt;RO</strong>和R</p>
<p><img src="clip_image003.png" alt></p>
<p>此时可以是将o删除 dp[i-1][j]+1(i-1就是删除i)或者是将o替换成null</p>
<p><img src="clip_image004.png" alt></p>
<p>此时可以将o插入dp[i][j-1]+1(插入也相当于删除第j个元素)</p>
<p>因此我们可以得到</p>
<p>If(word1[i]==word1[j])</p>
<p>​    Dp[i][j]=dp[i-1][j-1]</p>
<p>Else</p>
<p>​    Dp[i][j]=Min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1;</p>
<table>
<thead>
<tr>
<th><strong>0</strong></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>每次pre一开始肯定是dp[0],然后是dp[1]…dp[m],循环了一遍后</p>
<p>又是从dp[0]开始。因为循环没有改变dp[0]的值，因此需要改变。（在二维里面可以初始化dp[i][0]），在一维的里面必须手动初始化。</p>
<p>其实从另外一个角度去想问题，题目和你说了增删改都行。因此你可以不用题目的例子自己想例子，然后去推出里面的关系比如说ac和acd就可以推出增删（还有相等）的情况，然后ad和ac就可以推出改的情况。题目例子往往没那么好一眼看出其中的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] w1=word1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] w2=word2.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n=w1.length,m=w2.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)   dp[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)   dp[<span class="number">0</span>][i]=i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=m ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(w1[i-<span class="number">1</span>]==w2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j]=Math.min(Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>降维打击</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] w1=word1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] w2=word2.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n=w1.length,m=w2.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)   dp[i]=i;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>,pre=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">        pre = dp[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=m ; j++) &#123;</span><br><span class="line">            tmp=dp[j];</span><br><span class="line">            <span class="keyword">if</span>(w1[i-<span class="number">1</span>]==w2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[j]=pre;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[j]=Math.min(Math.min(dp[j],dp[j-<span class="number">1</span>]),pre)+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="44-wildcard-matching-">44. Wildcard Matching -</span></h2><p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。</p>
<p>‘?’ 可以匹配任何单个字符。<br> ‘*’ 可以匹配任意字符串（包括空字符串）。</p>
<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
<p><strong>说明</strong>:</p>
<p>·  s 可能为空，且只包含从 a-z 的小写字母。</p>
<p>·  p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。</p>
<p><strong>示例</strong> <strong>1:</strong></p>
<p>输入:<br> s = “aa”<br> p = “a”<br> 输出: false<br> 解释: “a” 无法匹配 “aa” 整个字符串。</p>
<p><strong>示例</strong> <strong>2:</strong></p>
<p>输入:<br> s = “aa”<br> p = “*”<br> 输出: true<br> 解释: ‘*’ 可以匹配任意字符串。</p>
<p><strong>示例</strong> <strong>3:</strong></p>
<p>输入:<br> s = “cb”<br> p = “?a”<br> 输出: false<br> 解释: ‘?’ 可以匹配 ‘c’, 但第二个 ‘a’ 无法匹配 ‘b’。</p>
<p><strong>示例</strong> <strong>4:</strong></p>
<p>输入:<br> s = “adceb”<br> p = “<em>a</em>b”<br> 输出: true<br> 解释: 第一个 ‘<em>‘ 可以匹配空字符串, 第二个 ‘</em>‘ 可以匹配字符串 “dce”.</p>
<p><strong>示例</strong> <strong>5:</strong></p>
<p>输入:<br> s = “acdcb”<br> p = “a*c?b”<br> 输入: false</p>
<p><img src="clip_image001-1585225470642.png" alt></p>
<p>题目给定两个字符串，一个字符串是匹配串，除了小写字母外，匹配串里面还包含 * 和 ? 这两个特殊字符，另一个是普通字符串，里面只包含小写字母。</p>
<p>题目问这个普通字符串是否和匹配字符串相匹配，匹配规则是 ? 可以匹配单个字符，* 可以匹配一个区间，也就是多个字符，当然也可以匹配 0 个字符，也就是空串。</p>
<p>依然是四个步骤走一遍：</p>
<p>·  问题拆解</p>
<p>做多了，你发现这种问题其实都是一个套路，老样子，我们还是根据我们要求解的问题去看和其直接相关的子问题，我们需要求解的问题是 pattern(0…m) 和 str(0…n) 是否匹配，<strong>这里的核心依然是字符之间的比较，但是和之前不同的是，这个比较不仅仅是看两个字符相不相等，它还有了一定的匹配规则在里面</strong>，那我们就依次枚举讨论下：</p>
<p>pattern(m) == str(n):<br> 问题拆解成看子问题 pattern(0…m-1) 和 str(0…n-1) 是否匹配</p>
<p>pattern(m) == ?:<br> 问题拆解成看子问题 pattern(0…m-1) 和 str(0…n-1) 是否匹配</p>
<p><font color="blue">pattern(m) == *:可以匹配空串、以及任意多个字符</font></p>
<p>当 * 匹配空串时：问题拆解成看子问题 pattern(0…m-1) 和 str(0…n) 是否匹配</p>
<p>当 * 匹配任意字符时：问题拆解成看子问题 pattern(0…m) 和 str(0…n-1) 是否匹配</p>
<p>这里解释一下，<em>匹配任意多个字符意味着之前的子问题也可以使用当前的</em>，也就是用 pattern(m) 来进行匹配，因此，当前问题可以拆解成子问题 pattern(0…m) 和 str(0…n-1) 是否匹配，你发现弄来弄去，子问题依然是那三个：</p>
<p>·  pattern(0…m-1) 和 str(0…n-1) 是否匹配</p>
<p>·  pattern(0…m-1) 和 str(0…n) 是否匹配</p>
<p>·  pattern(0…m) 和 str(0…n-1) 是否匹配</p>
<p>不知道你是否发现了字符匹配类动态规划问题的共性，如果是画表格，你只需要关注当前格子的<font color="orange"> <strong>左边、上边、左上</strong></font> 这三个位置的相邻元素，因为表格有实际数据做辅助，所以画表格有时可以帮助你找到问题与子问题之间的联系。</p>
<p>·  状态定义</p>
<p>还是老样子，dp[i][j] 表示的就是问题 pattern(0…i) 和 str(0…j) 的答案，直接说就是 pattern(0…i) 和 str(0…j) 是否匹配</p>
<p>·  递推方程</p>
<p>把之前 “问题拆解” 中的文字描述转换成状态的表达式就是递推方程：</p>
<p>pattern(i) == str(j) || pattern(i) == ‘?’:<br> dp[i][j] = dp[i - 1][j - 1]</p>
<p> pattern(i) == ‘*’:<br> dp[i][j] = dp[i - 1][j] || dp[i][j - 1]</p>
<p>·  实现</p>
<p>这类问题的状态数组往往需要多开一格，主要是为了考虑空串的情况，这里我就不赘述了。</p>
<p>我想说的是，关于初始化的部分，如果 str 是空的，pattern 最前面有 *，因为 * 是可以匹配空串的，因此这个也需要记录一下，反过来，如果 pattern 是空的，str 只要不是空的就无法匹配，这里就不需要特别记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] sArr = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] pArr = p.toCharArray();</span><br><span class="line">   <span class="keyword">int</span> n=pArr.length,m=sArr.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类似p="**a" s="a"条件下        </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pArr[i - <span class="number">1</span>] != <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=m ; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pArr[i-<span class="number">1</span>]==sArr[j-<span class="number">1</span>]||pArr[i-<span class="number">1</span>]==<span class="string">'?'</span>) dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(pArr[i-<span class="number">1</span>]==<span class="string">'*'</span>) dp[i][j] = dp[i-<span class="number">1</span>][j]||dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>降维打击！</p>
<p>S=” acdcb”</p>
<p>P= “a*c?b”</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>Null</strong></th>
<th><strong>A</strong></th>
<th><strong>C</strong></th>
<th><strong>D</strong></th>
<th><strong>C</strong></th>
<th><strong>B</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Null</strong></td>
<td><strong>T</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
</tr>
<tr>
<td><strong>A</strong></td>
<td><strong>F</strong></td>
<td><strong>T</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
</tr>
<tr>
<td>*****</td>
<td><strong>F</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
</tr>
<tr>
<td><strong>C</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>T</strong></td>
<td><strong>F</strong></td>
<td><strong>T</strong></td>
<td><strong>F</strong></td>
</tr>
<tr>
<td><strong>?</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>T</strong></td>
<td><strong>F</strong></td>
<td><strong>T</strong></td>
</tr>
<tr>
<td><strong>B</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th><strong>Null</strong></th>
<th><strong>A</strong></th>
<th><strong>C</strong></th>
<th><strong>D</strong></th>
<th><strong>C</strong></th>
<th><strong>B</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Null</strong></td>
<td><strong>T</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
</tr>
<tr>
<td><strong>A</strong></td>
<td><strong>F</strong></td>
<td><strong>T</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
<td><strong>F</strong></td>
</tr>
<tr>
<td>*****</td>
<td><strong>F</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
<td><strong>T</strong></td>
</tr>
<tr>
<td><strong>C</strong></td>
<td><strong>F</strong></td>
<td><strong>Position1</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>?</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>B</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>由于上面都是FTTTTT而position1的时候应该是false，由于二维数组默认初始化是false，一维数组是继承上一次的值，因此判断条件得改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch1</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] sArr = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] pArr = p.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n=pArr.length,m=sArr.length;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> tmp,pre=<span class="keyword">true</span>;              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">        pre=dp[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=dp[<span class="number">0</span>]&amp;&amp; pArr[i-<span class="number">1</span>]==<span class="string">'*'</span>; <span class="comment">//类似p="**a" s="a"条件下 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=m ; j++) &#123;</span><br><span class="line">            tmp=dp[j];</span><br><span class="line">            <span class="keyword">if</span>(pArr[i-<span class="number">1</span>]!=<span class="string">'*'</span>) dp[j]=pre&amp;&amp;(pArr[i-<span class="number">1</span>]==sArr[j-<span class="number">1</span>]||pArr[i-<span class="number">1</span>]==<span class="string">'?'</span>);</span><br><span class="line">            <span class="keyword">else</span> dp[j] = dp[j]||dp[j-<span class="number">1</span>];</span><br><span class="line">            pre=tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>难度挺大的，我也不能自己改出来。</p>
<h2><span id="10-regular-expression-matching">10. Regular Expression Matching ×</span></h2><p>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</p>
<p>‘.’ Matches any single character.</p>
<p>‘*’ Matches zero or more of the preceding element.</p>
<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
<p><strong>Note:</strong></p>
<ul>
<li>s could be empty and     contains only lowercase letters a-z.</li>
<li>p could be empty and     contains only lowercase letters a-z, and characters     like . or *.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong></p>
<p>s = “aa”</p>
<p>p = “a”</p>
<p><strong>Output:</strong> false</p>
<p><strong>Explanation:</strong> “a” does not match the entire string “aa”.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong></p>
<p>s = “aa”</p>
<p>p = “a*”</p>
<p><strong>Output:</strong> true</p>
<p><strong>Explanation:</strong> ‘*’ means zero or more of the preceding element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong></p>
<p>s = “ab”</p>
<p>p = “.*”</p>
<p><strong>Output:</strong> true</p>
<p><strong>Explanation:</strong> “.*” means “zero or more (*) of any character (.)”.</p>
<p><strong>Example 4:</strong></p>
<p><strong>Input:</strong></p>
<p>s = “aab”</p>
<p>p = “c<em>a</em>b”</p>
<p><strong>Output:</strong> true</p>
<p><strong>Explanation:</strong> c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches “aab”.</p>
<p><strong>Example 5:</strong></p>
<p><strong>Input:</strong></p>
<p>s = “mississippi”</p>
<p>p = “mis<em>is*p</em>.”</p>
<p><strong>Output:</strong> false</p>
<p>和上一道题有点像但是有点不同，还是先画图。</p>
<p><img src="clip_image001-1585282035109.png" alt></p>
<p><strong>遇到初始化问题我们也可以画图，然后我们需要</strong></p>
<p>c*可以看做是null</p>
<p>因此c<em>==null初始化为true同理c</em>a*也是true</p>
<p>l 匹配空串aa*和aa</p>
<p>dp[i][j]=dp[i-1][j];</p>
<p>l 匹配0个前一个字符，bc* b</p>
<p> dp[i][j]=dp[i-2][j]</p>
<p>l 然后它还有一个功能就是匹配n个前个字符a*和aaaaaa</p>
<p>那么我们就需要判断a<em>的第一个a和aaaa的后面几个a一不一样，否则会出现a</em>匹配abbb等等情况，或者说.*可以匹配abccdd等等情况。</p>
<p><strong>1.</strong>   <strong>ba*</strong>和b这种情况下，b和a不相等，那么*只有消除a的情况下才可能匹配**</p>
<p><strong>2.</strong>   <strong>如果是p[]相等的情况下。</strong></p>
<p><strong>如果是a*和aaaa这种情况下，此时*下标为i只有a[i-1]和a[j]相等的情况下，*代表n个a才是有意义的。</strong>dp[i][j-1]</p>
<p><strong>“aaa”</strong>和”ab*a*c*a”情况下，b*和c*为空且a*只能代表一个a，</p>
<p><em>B*</em>为空就是等于dp[i][j]=dp[i-2][j];</p>
<p><em>a*</em>代表一个a就等于dp[i][j]=dp[i-1][j]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] s1 = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] p1 = p.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> n=s1.length,m=p1.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">        <span class="keyword">if</span>(p1[i-<span class="number">1</span>]==<span class="string">'*'</span>&amp;&amp;dp[i-<span class="number">2</span>][<span class="number">0</span>]) dp[i][<span class="number">0</span>]=<span class="keyword">true</span>;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1[i-<span class="number">1</span>]==<span class="string">'.'</span>||s1[j-<span class="number">1</span>]==p1[i-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(p1[i-<span class="number">1</span>]==<span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p1[i-<span class="number">2</span>]==s1[j-<span class="number">1</span>]||p1[i-<span class="number">2</span>]==<span class="string">'.'</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i][j-<span class="number">1</span>]||dp[i-<span class="number">1</span>][j]||dp[i-<span class="number">2</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">2</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="97-interleaving-string">97. Interleaving String ×</span></h2><p>给定三个字符串 <em>s1</em>, <em>s2</em>, <em>s3</em>, 验证 <em>s3</em> 是否是由 <em>s1</em> 和 <em>s2</em> 交错组成的。</p>
<p><strong>示例</strong> <strong>1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong> <strong>2:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = <span class="string">"aabcc"</span>, s2 = <span class="string">"dbbca"</span>, s3 = <span class="string">"aadbbbaccc"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] c1=s1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] c2=s2.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] c3=s3.toCharArray();</span><br><span class="line">    <span class="keyword">while</span>(k&lt;c3.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;c1.length&amp;&amp;c3[k]==c1[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;c2.length&amp;&amp;c3[k]==c2[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="orange"><strong>用三个指针并不行，因为如果s3=cac ，s1=c，s2=ca就不行了。所以还是dp解，如果s1和s2没有共同的字符那么就可以过了</strong></font></p>
<p>题目的输入是三个字符串，问其中两个字符串是否能够交错合并组成第三个字符串，<font color="orange"><strong>一个字符相对于其他字符的顺序在合并之后不能改变</strong></font>，这也是这道题的难点，不然的话你用一个哈希表就可以做了，三个字符串是否意味着要开三维的状态数组？还是四个步骤来看看：</p>
<p>·  问题拆解</p>
<p>在拆解问题之前，我们必须保证前两个字符串的字符的总数量必须正好等于第三个字符串的字符总数量，不然的话，再怎么合并也无法完全等同。这里有一个点，当我们考虑 str1(0…i) 和 str2(0…j) 的时候，其实第三个字串需要考虑的范围也就确定了，就是 str3(0…i+j)。如果我们要求解问题 str1(0…m) 和 str2(0…n) 是否能够交错组成 str3(0…m+n)，还是之前那句话，<font color="orange"><strong>字符串匹配问题的核心永远是字符之间的比较</strong>：</font></p>
<p>·  如果 str1(m) == str3(m+n)，问题拆解成考虑子问题 str1(0…m-1) 和 str2(0…n) 是否能够交错组成 str3(0…m+n-1)</p>
<p>·  如果 str2(n) == str3(m+n)，问题拆解成考虑子问题 str1(0…m) 和 str2(0…n-1) 是否能够交错组成 str3(0…m+n-1)</p>
<p>你可能会问需不需要考虑子问题 str1(0…m-1) 和 str2(0…n-1)？</p>
<p>在这道题目当中，<strong>不需要</strong>！</p>
<p>千万不要题目做多了就固定思维了，之前说到这类问题可以试着考虑三个相邻子问题是为了让你有个思路，能更好地切题，并不是说所有的字符串匹配问题都需要考虑这三个子问题，我们需要遇到具体问题具体分析。</p>
<p>·  状态定义</p>
<p>dp[i][j] 表示的是 str1(0…i) 和 str2(0…j) 是否可以交错组成 str3(0…i+j)，这里再补充说明下为什么我们不需要开多一维状态来表示 str3，其实很简单，str3 的状态是由 str1 str2 决定的，str1 str2 定了，str3 就定了</p>
<p>·  递推方程</p>
<p>把之前问题拆解中的文字描述转换成状态的表达式就是递推方程：</p>
<p>str1(i) == str3(i+j)<br> dp[i][j] |= dp[i - 1][j]</p>
<p> str2(j) == str3(i+j)<br> dp[i][j] |= dp[i][j - 1]</p>
<p>·  实现</p>
<p>初始化的时候需要考虑单个字符串能否组成 str3 对应的区间，这个比较简单，直接判断前缀是否相等即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = s1.length();</span><br><span class="line">    <span class="keyword">int</span> length2 = s2.length();</span><br><span class="line">    <span class="keyword">int</span> length3 = s3.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length1 + length2 != length3) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[length1 + <span class="number">1</span>][length2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] sArr1 = s1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] sArr2 = s2.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] sArr3 = s3.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length1; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] &amp;&amp; sArr1[i - <span class="number">1</span>] == sArr3[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length2; ++i) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; sArr2[i - <span class="number">1</span>] == sArr3[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= length1; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= length2; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sArr3[i + j - <span class="number">1</span>] == sArr1[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sArr3[i + j - <span class="number">1</span>] == sArr2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] |= dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也是能降维打击的（降维打击的难点在于初始化以及temporary memo），能做出来就行了其实，但是面试可能问怎么优化。</p>
<p>如果还是没有思路，那就画画表格吧，考虑当前格子的时候，看看其 <font color="orange"><strong>左边</strong>，<strong>上边</strong>，<strong>左上边</strong> </font>这三个格子所代表的子问题的状态，有实际数据作为辅助，问题之间的递进关系相对来说会比较好找些。</p>
<h1><span id="概率dp问题">概率DP问题</span></h1><h2><span id="4-信件错排">4. 信件错排 ×</span></h2><p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p>
<p>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</p>
<ul>
<li>i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</li>
<li>i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。</li>
</ul>
<p>综上所述，错误装信数量方式数量为：</p>
<p>​                              <img src="image-20200327142057967.png" alt> </p>
<h2><span id="5-母牛生产">5. 母牛生产 √</span></h2><p>题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p>
<p>第 i 年成熟的牛的数量为：                               </p>
<p><img src="image-20200327144441491.png" alt></p>
<h1><span id="各种game集合">各种Game集合</span></h1><h2><span id="1025-divisor-game">1025. Divisor Game ×</span></h2><p>Alice and Bob take turns playing a game, with Alice starting first.</p>
<p>Initially, there is a number <code>N</code> on the chalkboard. On each player’s turn, that player makes a <em>move</em> consisting of:</p>
<ul>
<li>Choosing any <code>x</code> with <code>0 &lt; x &lt; N</code> and <code>N % x == 0</code>.</li>
<li>Replacing the number <code>N</code> on the chalkboard with <code>N - x</code>.</li>
</ul>
<p>Also, if a player cannot make a move, they lose the game.</p>
<p>Return <code>True</code> if and only if Alice wins the game, assuming both players play optimally.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Alice chooses 1, and Bob has no more moves.</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.</span><br></pre></td></tr></table></figure>

<p>Game类问题都有一个特性，就是无论A还是B玩，都是在同样一个规则下做游戏，A或者B都不会对结果改变。</p>
<p> 其实就是DP问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> dp[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j==<span class="number">0</span>&amp;&amp;dp[i-j]==<span class="keyword">false</span>)</span><br><span class="line">                dp[i]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>数学证明法:</p>
<p>Prove it by two steps:</p>
<ol>
<li>if Alice will lose for N, then Alice will must win for N+1,     since Alice can first just make N decrease 1.</li>
<li>for any odd number N, it only has odd factor, so after the     first move, it will be an even number</li>
</ol>
<p>let’s check the inference<br> fisrt N = 1, Alice lose. then Alice will must win for 2.<br> if N = 3, since all even number(2) smaller than 3 will leads Alice win, so Alice will lose for 3<br> 3 lose -&gt; 4 win<br> all even number(2,4) smaller than 5 will leads Alice win, so Alice will lose for 5<br> …</p>
<p>Therefore, Alice will always win for even number, lose for odd number.</p>
<h2><span id="877-stone-game">877. Stone Game</span></h2><p>Alex and Lee play a game with piles of stones. There are an even number of piles <strong>arranged in a row</strong>, and each pile has a positive integer number of stones <code>piles[i]</code>.</p>
<p>The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties.</p>
<p>Alex and Lee take turns, with Alex starting first. Each turn, a player takes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.</p>
<p>Assuming Alex and Lee play optimally, return <code>True</code> if and only if Alex wins the game.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,3,4,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">Alex starts first, and can only take the first 5 or the last 5.</span><br><span class="line">Say he takes the first 5, so that the row becomes [3, 4, 5].</span><br><span class="line">If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.</span><br><span class="line">If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.</span><br><span class="line">This demonstrated that taking the first 5 was a winning move for Alex, so we return true.</span><br></pre></td></tr></table></figure>



<h1><span id="股票问题状态机">股票问题（状态机）</span></h1><p>先讲一下状态机：</p>
<p><img src="clip_image001.jpg" alt></p>
<p>类似于这样的图就叫做状态机，状态只能为状态0，状态1和状态2.</p>
<p>而且它们之间是可以互相转换的，且有一定的条件发生转换。</p>
<p>例如图一：</p>
<p>状态0可以保持状态0，也可以通过消抖进入状态1.</p>
<p>状态1可以通过确认变为状态2或者通过干扰变成状态0.</p>
<p>之前也学过状态机。这只是个例子，让你可以对状态机有一个大体的理解，实际上根据不同的问题，我们可以画出不同的状态机。 </p>
<p>状态机可以很简单的解决一系列的hard问题。</p>
<p>可以先看看我写的《最大子序列》</p>
<p>然后我们可以用一种独特的方法再来看待这道题。</p>
<p>看股票问题前先看完背包问题。</p>
<h2><span id="leetcode-121-best-time-to-buy-and-sell-stock">Leetcode 121 Best Time to Buy and Sell Stock √</span></h2><p> 给定一个数组prices，prices[i]表示股票在第i天的价格（买入or卖出），在卖出股票之前必须先买进，且手中不能同时买进两份股票，现在允许做<strong>恰好一次交易</strong>，求最大收益。</p>
<p>样例：</p>
<p>输入：[7, 1, 5, 3, 6, 4]</p>
<p>输出：5</p>
<p>输入：[7, 6, 4, 3, 1]</p>
<p>输出：0</p>
<p>正常解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">     min = prices[i]&lt;min?prices[i]:min;</span><br><span class="line">     res = Math.*max*(prices[i]-min,res);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>我们声明：</p>
<p>定义sell表示截止到当天，卖之后能得到的最大收益</p>
<p>定义buy表示截止到当天，买之后能得到的最大收益</p>
<p>我们可以画出状态机：（画的有点差）</p>
<p><img src="clip_image002-1585294076856.png" alt></p>
<p>就是说它有两个状态，一个是BUY，一个是SELL。</p>
<p>买入必须在卖出之前，且卖出必须依赖于上一个买入的值。</p>
<p><strong>BUY可以保存BUY的状态或者通过买入进入SELL状态。</strong></p>
<p><strong>SELL可以保存SELL的状态或者通过卖出退出状态。</strong></p>
<p>卖完后就结束了。</p>
<p>因此我们可以写出递推式：</p>
<p>Buy = max(Buy,0-price[i]);</p>
<p>Sell=max(Sell,Buy+price[i]);</p>
<p>然后我们遍历一遍pirce数组，由于我们在一个循环里面同时做buy和sell。因此不会发生sell在buy之前。</p>
<p>又由于sell依赖于上次buy的值，而不是buy更新后的值。所以我们在进入循环前先初始化buy为-price[0]; sell为0（因为收益最少为0），在循环中先sell然后再buy。Sell处理初始化buy的值，然后buy更新buy的值。</p>
<p>如果要先执行buy再执行sell也可以。前提是得用一个变量先保存当前buy的值。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>1</strong></th>
<th><strong>2</strong></th>
<th><strong>3</strong></th>
<th><strong>4</strong></th>
<th><strong>5</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Sell</strong></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td><strong>Buy</strong></td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
<td>-1</td>
</tr>
<tr>
<td><strong>Statue</strong></td>
<td>buy</td>
<td></td>
<td></td>
<td></td>
<td>sell</td>
</tr>
</tbody></table>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stateMachine</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> buy=-prices[<span class="number">0</span>],sell=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">     sell=Math.*max*(sell, buy+prices[i]);</span><br><span class="line">     buy=Math.*max*(buy, <span class="number">0</span>-prices[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sell;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>或者用tmp保存上次buy的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stateMachine1</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> buy=-prices[<span class="number">0</span>],sell=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">     <span class="keyword">int</span> tmp = buy;</span><br><span class="line">     buy=Math.*max*(buy, -prices[i]);</span><br><span class="line">     sell=Math.*max*(sell, tmp+prices[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sell;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当然其实不用tmp保存也是可以的，就相当于初始化为price[0]或者price[1]的最小值，也就是-price[0]或者-price[1]的最大值。</p>
<h2><span id="leetcode-122-best-time-to-buy-and-sell-stock-ii">Leetcode 122 Best Time to Buy and Sell Stock II √</span></h2><p>给定一个数组prices，prices[i]表示股票在第i天的价格（买入or卖出），在卖出股票之前必须先买进，且手中不能同时买进两份股票，现在允许做<strong>无数次交易</strong>，求最大收益。</p>
<p>输入：[7, 1, 5, 3, 6, 4]</p>
<p>输出：7</p>
<p>输入：[1, 2, 3, 4, 5]</p>
<p>输出：4</p>
<p>正常解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, buy, sell, profit = <span class="number">0</span>, N = prices.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; N) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; N &amp;&amp; prices[i + <span class="number">1</span>] &lt;= prices[i]) i++;</span><br><span class="line">        buy = prices[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; N &amp;&amp; prices[i + <span class="number">1</span>] &gt; prices[i]) i++;</span><br><span class="line">        sell = prices[i];</span><br><span class="line"></span><br><span class="line">        profit += sell - buy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第一步：下定义</p>
<p>定义sell表示截止到当天，卖之后能得到的最大收益</p>
<p>定义buy表示截止到当天，买之后能得到的最大收益</p>
<p>第二步：画状态机</p>
<p> <img src="image-20200327154233734.png" alt></p>
<p>第三步：写递推式</p>
<p>BUY = max(BUY,SELL-PRICE[I]);</p>
<p>SELL = max(SELL,BUY+PRICE[I]);</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>7</strong></th>
<th><strong>1</strong></th>
<th><strong>5</strong></th>
<th><strong>3</strong></th>
<th><strong>6</strong></th>
<th><strong>4</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Sell</strong></td>
<td>0</td>
<td>0</td>
<td>4</td>
<td>4</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td><strong>buy</strong></td>
<td>-7</td>
<td>-1</td>
<td>-1</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td><strong>statue</strong></td>
<td></td>
<td>Buy</td>
<td>Sell</td>
<td>Buy</td>
<td>Sell</td>
<td>buy</td>
</tr>
</tbody></table>
<p>我们可以看到：</p>
<ol>
<li><p>因为都是取最大值max，所以buy和sell都是上升的</p>
</li>
<li><p>Buy依赖于上一个sell，sell依赖于上一个buy</p>
</li>
</ol>
<p>第四步：写代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = -prices[<span class="number">0</span>],sell=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">           <span class="keyword">int</span> tmp = sell;</span><br><span class="line">           sell=Math.max(sell,prices[i]+buy);</span><br><span class="line">           buy=Math.max(buy,tmp-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先卖再买还是因为我们已经初始化了buy了，默认让它选择第一个元素，因此可以选择卖或者不变。</p>
<h2><span id="leetcode-123-best-time-to-buy-and-sell-stock-iii">Leetcode 123 Best Time to Buy and Sell Stock III √</span></h2><p>给定一个数组prices，prices[i]表示股票在第i天的价格（买入or卖出），在卖出股票之前必须先买进，且手中不能同时买进两份股票，现在允许做<strong>最多两次交易</strong>，求最大收益。 </p>
<p>输入：[3,3,5,0,0,3,1,4]</p>
<p>输出：6 </p>
<p>输入：[1, 2, 3, 4, 5]</p>
<p>输出：4 </p>
<p>OK</p>
<p>还是四步走！</p>
<p>自己试试看，其实画出状态图就行了。</p>
<p>Step1:</p>
<p>定义sell0表示截止到当天，第一次卖之后能得到的最大收益</p>
<p>定义buy0表示截止到当天，第一次买之后能得到的最大收益</p>
<p>定义sell1表示截止到当天，第二次卖之后能得到的最大收益</p>
<p>定义buy1表示截止到当天，第二次买之后能得到的最大收益</p>
<p>Step2:</p>
<p> <img src="image-20200327154943779.png" alt></p>
<p>Step3:</p>
<p>注意如何初始化！！</p>
<p>BUY2定义为多少？</p>
<p>首先BUY2的值必须等于sell1-price[i]吧，所以buy2就必须初始化为最小值</p>
<p>Integer.<em>MIN_VALUE</em></p>
<p>那Sell2呢？也是0</p>
<p>因此：</p>
<p>SELL1=MAX(SELL1,BUY1+PRICE[I]);</p>
<p>BUY1=MAX(BUY1, 0-PRICE[I]);</p>
<p>SELL2=MAX(SELL2,BUY2+PRICE[I]);</p>
<p>BUY2=MAX(BUY2,SELL1-PRICE[I]);</p>
<p>这里有什么问题吗？</p>
<p>尽管我们在这里利用颠倒buy和sell的顺序来做（为什么颠倒可以避免更新？因为我们初始化了buy和sell，如果不初始化buy1的话我们要正序，但是正序就需要更多的tmp来保存状态了，不知道能不能理解）。BUY2依赖于上个SELL1的值，但是在BUY2更新之前SELL1就已经更新了，因此需要保存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buy1= -prices[<span class="number">0</span>],sell1=<span class="number">0</span>,buy2=Integer.MIN_VALUE,sell2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = sell1;</span><br><span class="line">        sell1 = Math.max(sell1, buy1+prices[i]);</span><br><span class="line">        buy1 = Math.max(buy1, <span class="number">0</span>-prices[i]);</span><br><span class="line"></span><br><span class="line">        sell2 = Math.max(sell2, buy2+prices[i]);</span><br><span class="line">        buy2 =  Math.max(buy2, tmp-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sell2,sell1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>但是实际上我们还可以颠倒sell1和sell2的顺序,而不需要tmp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> buy1= -prices[<span class="number">0</span>],sell1=<span class="number">0</span>,buy2=Integer.MIN_VALUE,sell2=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;            </span><br><span class="line">           sell2 = Math.max(sell2, buy2+prices[i]);</span><br><span class="line">           buy2 =  Math.max(buy2, sell1-prices[i]);</span><br><span class="line">           </span><br><span class="line">           sell1 = Math.max(sell1, buy1+prices[i]);</span><br><span class="line">           buy1 = Math.max(buy1, -prices[i]);           </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(sell2,sell1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2><span id="leetcode-188-best-time-to-buy-and-sell-stock-iv">Leetcode 188 Best Time to Buy and Sell Stock IV ×</span></h2><p>给定一个数组prices，prices[i]表示股票在第i天的价格（买入or卖出），在卖出股票之前必须先买进，且手中不能同时买进两份股票，现在允许做<strong>最多</strong>K次交易，求最大收益。</p>
<p>输入：[2, 4, 1], k = 2</p>
<p>输出：2</p>
<p>输入：[3,2,6,5,0,3], k = 2</p>
<p>输出：7</p>
<p>刚刚两次交易我们需要buy1 buy2 sell1 sell2，所以K次交易需要多少个sell buy呢？K个吗？</p>
<p>不一定对。</p>
<p>当K&gt;=给定数组长度/2 即：price.length/2的时候，我们可以理解为买卖无数次的结果，因此相对于第二题。为什么要想那么麻烦呢？因为第二题是O(n)的解法。</p>
<p>初始化buy可以都填充-prices[0]的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>||k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (prices.length/<span class="number">2</span>&lt;=k) <span class="keyword">return</span> maxProfit(prices);</span><br><span class="line">    <span class="keyword">int</span>[] buy = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] sell= <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    Arrays.fill(buy, Integer.MIN_VALUE);</span><br><span class="line">    buy[<span class="number">1</span>] = -prices[<span class="number">0</span>];   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            buy[j] = Math.max(buy[j],sell[j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">            sell[j] = Math.max(sell[j],buy[j]+prices[i]);            </span><br><span class="line">            res=Math.max(res,sell[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> buy = -prices[<span class="number">0</span>],sell=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = sell;</span><br><span class="line">        sell = Math.max(sell, buy+prices[i]);</span><br><span class="line">        buy = Math.max(buy, tmp-prices[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="leetcode-309-best-time-to-buy-and-sell-stock-with-cooldown">Leetcode 309 Best Time to Buy and Sell Stock with Cooldown √</span></h2><p>给定一个数组prices，prices[i]表示股票在第i天的价格（买入or卖出），在卖出股票之前必须先买进，且手中不能同时买进两份股票，现在允许做<strong>无数次交易，但每次卖出之后必须至少休息一天</strong>，求最大收益。</p>
<p>输入：[1,2,3,0,2]</p>
<p>输出：3</p>
<p>自己做吧</p>
<p>定义sell表示截止到当天，卖之后能得到的最大收益</p>
<p>定义buy表示截止到当天，买之后能得到的最大收益</p>
<p>定义rest表示截止到当天，休息之后能得到的最大收益</p>
<p>Rest的初始值？？</p>
<p>按顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = -prices[<span class="number">0</span>],sell=<span class="number">0</span>,rest=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rest;</span><br><span class="line">            rest = Math.max(rest, sell);</span><br><span class="line">            sell = Math.max(sell,buy+prices[i]);</span><br><span class="line">            buy = Math.max(buy, tmp-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2><span id="leetcode-714-best-time-to-buy-and-sell-stock-with-transcation-fee">Leetcode 714 Best Time to Buy and Sell Stock with Transcation Fee √</span></h2><p>给定一个数组prices，prices[i]表示股票在第i天的价格（买入or卖出），在卖出股票之前必须先买进，且手中不能同时买进两份股票，现在允许做<strong>无数次交易，但每次卖出需要支付一定的手续费</strong>，求最大收益。</p>
<p>输入：[1, 3, 2, 8, 4, 9], fee = 2</p>
<p>输出：8</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices==<span class="keyword">null</span>||prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy=-prices[<span class="number">0</span>],sell=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">int</span> tmp = sell;</span><br><span class="line">            sell = Math.max(sell, buy+prices[i]-fee);</span><br><span class="line">            buy = Math.max(buy, tmp-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: 'd154fff64901622afbb6',
  clientSecret: '5b3f1d58c331b54703e4477e1f8fa1e42e9c1082',
  repo: 'Disda-coding.github.io',
  owner: 'Disda-coding',
  admin: ['Disda-coding'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">Disda.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> </a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Disda.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>